<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>CSV → Aggregates + Cards + Data Table (Auto + Manual + More Charts, Improved)</title>

<!-- Chart.js v4 -->
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.3/dist/chart.umd.min.js"></script>
<!-- PapaParse -->
<script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>

<style>
  :root{
  /* Light palette */
  --bg:#f7fafc;            /* page bg */
  --panel:#ffffff;         /* main cards/sections */
  --panel2:#f9fafb;        /* secondary cards */
  --panel-bg:#ffffff;      /* tables/charts bg */
  --ink:#0b1220;           /* primary text */
  --muted:#64748b;         /* secondary text */
  --border:#e2e8f0;        /* borders */
  --accent:#2563eb;        /* brand accent (blue) */

  /* Elevation & shape */
  --radius-xs:8px; --radius:14px; --radius-lg:16px; --pill:999px;
  --shadow:0 8px 24px rgba(15, 23, 42, .08);

  /* Type & spacing */
  --fs-0:0.875rem; /* 14px */
  --fs-1:1rem;     /* 16px */
  --lh:1.5;

  --s-1:4px; --s-2:6px; --s-3:8px; --s-4:10px; --s-5:12px; --s-6:14px; --s-7:16px; --s-8:20px;
}

*{box-sizing:border-box}
html{color-scheme:light}
body{
  margin:0; background:var(--bg); color:var(--ink);
  font-family:system-ui, Segoe UI, Arial, sans-serif;
  font-size:var(--fs-0); line-height:var(--lh);
  text-rendering:optimizeLegibility; -webkit-font-smoothing:antialiased;
}

:root{ accent-color: var(--accent); }
::selection{background:color-mix(in oklab, var(--accent) 20%, transparent);}

*{scrollbar-color: var(--border) transparent;}
*::-webkit-scrollbar{height:10px;width:10px}
*::-webkit-scrollbar-thumb{background:var(--border);border-radius:8px}
*::-webkit-scrollbar-track{background:transparent}

.wrap{
  max-width: clamp(960px, 92vw, 1200px);
  margin: var(--s-8) auto;
  padding: 0 var(--s-7);
  box-shadow: 0 0 20px rgba(0, 0, 0, 0.05);
  border-radius: 16px;
  overflow: hidden;
}
.bar{
  display: flex;
  gap: var(--s-4);
  flex-wrap: wrap;
  align-items: center;
  background: linear-gradient(145deg, #f8fafc, #e2e8f0);
  border: 1px solid #e2e8f0;
  border-radius: 12px;
  padding: var(--s-3) var(--s-4);
  box-shadow: 0 2px 6px rgba(0, 0, 0, 0.03);
}

/* Controls */
input,button,select{
  background: #ffffff;
  color: var(--ink);
  border: 1px solid var(--border);
  border-radius: 10px;
  padding: var(--s-3) var(--s-4);
  box-shadow: 0 1px 2px rgba(15,23,42,.04);
  transition: all 0.2s ease;
}
input:focus,button:focus,select:focus{
  box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.2);
  border-color: var(--accent);
}
input::placeholder{color:color-mix(in oklab, var(--muted) 70%, transparent)}
button{
  cursor: pointer;
  background: linear-gradient(145deg, #f8fafc, #e2e8f0);
  transition: all 0.2s ease;
  font-weight: 500;
  border: 1px solid #cbd5e1;
}
button:hover{
  background: linear-gradient(145deg, #f1f5f9, #cbd5e1);
  transform: translateY(-1px);
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
}
button:active{
  transform: translateY(1px);
}
input:disabled, button:disabled{
  opacity: .6;
  cursor: not-allowed;
}

/* Focus */
:where(a,button,input,select,textarea,[tabindex]):focus-visible{
  outline:2px solid color-mix(in oklab, var(--accent) 80%, white 20%);
  outline-offset:2px; border-color:var(--accent);
}

.muted{color:var(--muted)}
.tag{
  background: linear-gradient(145deg, #e0e7ff, #c7d2fe);
  border: 1px solid #c7d2fe;
  color: #1e3a8a;
  padding: 2px 8px;
  border-radius: var(--pill);
  font-weight: 500;
  box-shadow: 0 1px 2px rgba(0, 0, 0, 0.05);
}

/* Tooltips */
.tooltip {
  position: relative;
  display: inline-block;
  cursor: help;
}

.tooltip::before {
  content: '?';
  display: inline-flex;
  align-items: center;
  justify-content: center;
  width: 16px;
  height: 16px;
  background: var(--accent);
  color: white;
  border-radius: 50%;
  font-size: 11px;
  font-weight: bold;
  margin-left: 4px;
  vertical-align: middle;
}

.tooltip::after {
  content: attr(data-tooltip);
  position: absolute;
  bottom: 125%;
  left: 50%;
  transform: translateX(-50%);
  background: rgba(15, 23, 42, 0.95);
  color: white;
  padding: 8px 12px;
  border-radius: 6px;
  font-size: 12px;
  line-height: 1.4;
  white-space: nowrap;
  opacity: 0;
  pointer-events: none;
  transition: opacity 0.2s;
  z-index: 1000;
  max-width: 300px;
  white-space: normal;
  text-align: left;
}

.tooltip:hover::after {
  opacity: 1;
}

.tooltip-wide::after {
  width: 200px;
  white-space: normal;
}

.help-text {
  color: var(--muted);
  font-size: 0.8rem;
  margin-top: 4px;
  line-height: 1.3;
}

/* Sections & grid */
.section{
  background: var(--panel);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  box-shadow: var(--shadow);
  padding: var(--s-6);
  margin: 16px 0;
  transition: all 0.3s ease;
  position: relative;
  overflow: hidden;
}

.section::before {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  height: 4px;
  background: linear-gradient(90deg, #2563eb, #3b82f6, #60a5fa);
}

.section:hover {
  box-shadow: 0 12px 36px rgba(0, 0, 0, 0.12);
  transform: translateY(-3px);
}
.grid{
  display: grid;
  gap: var(--s-6);
  grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
  grid-auto-rows: 10px;
  /* Ensure items start at top of their grid area (better for masonry) */
  align-items: start;
  max-width: 1200px;
  margin: 0 auto;
  padding: 0 var(--s-2);
}
@media (max-width:1000px){
  .grid{
    grid-template-columns:1fr;
    padding: 0;
  }
}

/* Cards */
.card{
  background: linear-gradient(145deg, #ffffff, #f8f9fa);
  border: 1px solid #e2e8f0;
  border-radius: var(--radius-lg);
  display: flex;
  flex-direction: column;
  min-height: 0;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.05), 0 1px 4px rgba(0, 0, 0, 0.05);
  transition: all 0.3s ease;
  position: relative;
  overflow: hidden;
}

.card::before {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  height: 4px;
  background: linear-gradient(90deg, #2563eb, #3b82f6, #60a5fa);
}

.card:hover {
  box-shadow: 0 8px 20px rgba(0, 0, 0, 0.1), 0 3px 6px rgba(0, 0, 0, 0.08);
  transform: translateY(-3px);
}
.card-head{
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 16px;
  border-bottom: 1px solid #edf2f7;
  background: linear-gradient(180deg, #ffffff, #f9fafb);
  border-radius: var(--radius-lg) var(--radius-lg) 0 0;
}
.card-title{margin:0; font-size:16px; font-weight: 600;}
.card-sub{font-size:13px; color:var(--muted)}
.card-controls{
  display: flex;
  gap: 10px;
  flex-wrap: wrap;
  padding: 12px 16px;
  border-bottom: 1px solid #edf2f7;
  background: linear-gradient(180deg, #f9fafb, #f1f5f9);
  border-radius: 0 0 var(--radius-lg) var(--radius-lg);
}
.chart-cards{
  display: grid;
  grid-template-columns: 1fr;
  gap: 12px;
  padding: 12px 16px;
  background: linear-gradient(145deg, #f8fafc, #e2e8f0);
  border: 1px solid #edf2f7;
  border-radius: 12px;
  margin: 12px 0;
  box-shadow: 0 2px 6px rgba(0, 0, 0, 0.03);
}
.chart-card{
  background: linear-gradient(145deg, #ffffff, #f8f9fa);
  border: 1px solid #e2e8f0;
  border-radius: 12px;
  padding: 12px;
  box-shadow: 0 4px 6px rgba(0, 0, 0, 0.05), 0 1px 3px rgba(0, 0, 0, 0.05);
  transition: box-shadow 0.2s ease, transform 0.2s ease;
}

.chart-card:hover {
  box-shadow: 0 6px 12px rgba(0, 0, 0, 0.1), 0 2px 4px rgba(0, 0, 0, 0.05);
  transform: translateY(-2px);
}
.chart-head {
  display: flex;
  gap: 12px;
  align-items: center;
  justify-content: space-between;
  margin-bottom: 12px;
  padding-bottom: 12px;
  border-bottom: 1px solid #edf2f7;
}

/* Charts */
.chart-box {
  height: 320px;
  position: relative;
  overflow: auto;
  contain: strict;
  background: linear-gradient(145deg, #ffffff, #f8f9fa);
  border-radius: 12px;
  padding: 10px;
  box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.05);
}
.chart-box canvas {
  display: block;
  height: 100% !important;
  min-width: 100%;
  border-radius: 8px;
}

/* Modern chart styling */
.chart-card {
  background: linear-gradient(145deg, #ffffff, #f8f9fa);
  border: 1px solid #e2e8f0;
  border-radius: 16px;
  padding: 16px;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.05), 0 1px 4px rgba(0, 0, 0, 0.05);
  transition: all 0.3s ease;
  position: relative;
  overflow: hidden;
}

.chart-card::before {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  height: 4px;
  background: linear-gradient(90deg, #2563eb, #3b82f6, #60a5fa);
}

.chart-card:hover {
  box-shadow: 0 8px 20px rgba(0, 0, 0, 0.1), 0 3px 6px rgba(0, 0, 0, 0.08);
  transform: translateY(-3px);
}

.chart-head {
  display: flex;
  gap: 12px;
  align-items: center;
  justify-content: space-between;
  margin-bottom: 12px;
  padding-bottom: 12px;
  border-bottom: 1px solid #edf2f7;
}

.chart-controls {
  display: flex;
  flex-wrap: wrap;
  gap: 10px;
  align-items: center;
  margin-bottom: 12px;
  background: linear-gradient(145deg, #f8fafc, #e2e8f0);
  border: 1px solid #e2e8f0;
  border-radius: 10px;
  padding: 10px;
}

.chart-controls select,
.chart-controls input,
.chart-controls button {
  font-size: 13px;
  padding: 6px 10px;
  border-radius: 8px;
  border: 1px solid #cbd5e1;
  box-shadow: 0 1px 2px rgba(0, 0, 0, 0.05);
  transition: all 0.2s ease;
}

.chart-controls select:focus,
.chart-controls input:focus {
  box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.2);
  border-color: #2563eb;
}

.chart-controls button {
  background: linear-gradient(145deg, #2563eb, #1d4ed8);
  color: white;
  border: 1px solid #1d4ed8;
  font-weight: 500;
  transition: all 0.2s ease;
  box-shadow: 0 2px 4px rgba(37, 99, 235, 0.2);
}

.chart-controls button:hover {
  background: linear-gradient(145deg, #1d4ed8, #1e40af);
  border-color: #1e40af;
  box-shadow: 0 4px 6px rgba(37, 99, 235, 0.3);
  transform: translateY(-1px);
}

.chart-controls button:active {
  transform: translateY(1px);
}

/* Mobile responsiveness */
@media (max-width: 768px) {
  .chart-box {
    height: 280px;
  }
  
  .chart-card {
    overflow: auto;
  }
}

/* Tablet responsiveness */
@media (max-width: 1024px) and (min-width: 769px) {
  .chart-box {
    height: 300px;
  }
}

/* Tables */
.table-wrap{
  padding: 16px;
  overflow: auto;
  background: linear-gradient(145deg, #f8fafc, #e2e8f0);
  border: 1px solid #edf2f7;
  border-radius: 12px;
  margin: 12px 0;
  box-shadow: 0 2px 6px rgba(0, 0, 0, 0.03);
}
.data-table-wrap {
  width: 100%;
  border: 1px solid var(--border);
  border-radius: 12px;
  overflow: auto;
  max-height: 520px;
  position: relative;
  background: var(--panel);
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05);
}
table{
  width: auto;
  border-collapse: collapse;
  background: var(--panel);
  box-shadow: 0 1px 2px rgba(15,23,42,.04);
  border-radius: 8px;
  overflow: hidden;
}
th,td{
  border-bottom:1px solid var(--border);
  padding: 10px 12px;
  white-space:nowrap;
  overflow:hidden;
  text-overflow:ellipsis;
  font-size: 14px;
}
th {
  min-width: 120px;
}
td {
  min-width: 100px;
}
th{
  position: sticky;
  top: 0;
  background: linear-gradient(180deg, #f8fafc, #e2e8f0);
  cursor: pointer;
  z-index: 2;
  font-weight: 600;
  text-transform: uppercase;
  font-size: 0.75rem;
  letter-spacing: 0.05em;
  transition: background 0.2s ease;
}
th:hover {
  background: linear-gradient(180deg, #f1f5f9, #e2e8f0);
}
th .sort{
  opacity:.7;
  margin-left:6px;
  transition: opacity 0.2s ease;
}
th:hover .sort {
  opacity: 1;
}
tbody tr:nth-child(even){
  background:#f8fafc
}
tbody tr:hover {
  background: #f1f5f9;
}

tfoot td{
  font-weight: 600;
  background: linear-gradient(0deg, #f8fafc, #e2e8f0);
  position: sticky;
  bottom: -1px;
  z-index: 1;
}

/* Sticky footer alternative */
.table-sticky-foot{
  position:sticky; bottom:0; background:#f1f5f9; border-top:1px solid var(--border);
  padding:6px 8px; display:flex; justify-content:flex-end; gap:10px;
}

.card-foot{
  display: flex;
  gap: 12px;
  flex-wrap: wrap;
  padding: 16px;
  border-top: 1px solid #edf2f7;
  background: linear-gradient(0deg, #f8fafc, #e2e8f0);
  border-radius: 0 0 var(--radius-lg) var(--radius-lg);
}
.small{font-size:13px}

/* Data table controls */
.table-controls{
  display: flex;
  gap: 12px;
  flex-wrap: wrap;
  align-items: center;
  margin: 12px 0;
  background: linear-gradient(145deg, #f8fafc, #e2e8f0);
  border: 1px solid #e2e8f0;
  border-radius: 12px;
  padding: 12px 16px;
  box-shadow: 0 2px 6px rgba(0, 0, 0, 0.03);
}
.table-controls label {
  font-size: 14px;
  font-weight: 500;
}
.table-controls input,
.table-controls select {
  font-size: 14px;
  padding: 8px 12px;
  border-radius: 8px;
  border: 1px solid #cbd5e1;
  box-shadow: 0 1px 2px rgba(0, 0, 0, 0.05);
  transition: all 0.2s ease;
}
.table-controls input:focus,
.table-controls select:focus {
  box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.2);
  border-color: #2563eb;
}
.pager{
  display: flex;
  gap: 8px;
  align-items: center;
}
.pager button{
  padding: 8px 12px;
  background: linear-gradient(145deg, #2563eb, #1d4ed8);
  color: white;
  border: 1px solid #1d4ed8;
  border-radius: 8px;
  font-weight: 500;
  transition: all 0.2s ease;
  box-shadow: 0 2px 4px rgba(37, 99, 235, 0.2);
}
.pager button:hover{
  background: linear-gradient(145deg, #1d4ed8, #1e40af);
  border-color: #1e40af;
  box-shadow: 0 4px 6px rgba(37, 99, 235, 0.3);
  transform: translateY(-1px);
}
.pager button:active{
  transform: translateY(1px);
}
.pager button:disabled{
  background: #94a3b8;
  border-color: #94a3b8;
  cursor: not-allowed;
  box-shadow: none;
  transform: none;
}
.count{
  color:var(--muted);
  font-size: 14px;
}
.data-table-wrap{
  border: 1px solid var(--border);
  border-radius: 12px;
  overflow: auto;
  max-height: 520px;
  position: relative;
  background: var(--panel);
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05);
}
.sticky{position:sticky; top:0; background:#f1f5f9; z-index:1}

/* Modal */
.modal{
  position: fixed;
  inset: 0;
  display: none;
  align-items: center;
  justify-content: center;
  background: rgba(15, 23, 42, 0.5);
  z-index: 50;
  backdrop-filter: blur(4px);
}
.modal.open{
  display: flex;
}
.modal-card{
  width: min(960px, 92vw);
  max-height: 86vh;
  overflow: auto;
  background: var(--panel);
  border: 1px solid var(--border);
  border-radius: 14px;
  box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
  padding: 14px;
  transform: translateY(4px);
  opacity: 0;
  transition: opacity 0.2s, transform 0.2s;
}
.modal.open .modal-card{
  transform: none;
  opacity: 1;
}
.modal-head{display:flex; justify-content:space-between; align-items:center; margin-bottom:10px}
.modal-head h3{margin:0}
.role-table{
  width: 100%;
  border-collapse: collapse;
  background: var(--panel);
  box-shadow: 0 1px 2px rgba(15,23,42,.04);
  border-radius: 8px;
  overflow: hidden;
}
.role-table th,
.role-table td{
  border-bottom: 1px solid var(--border);
  padding: 6px 8px;
}
.role-table th{
  background: linear-gradient(180deg, #f8fafc, #e2e8f0);
  font-weight: 600;
  text-transform: uppercase;
  font-size: 0.75rem;
  letter-spacing: 0.05em;
}

/* Toast */
.toast-container {
  position: fixed;
  bottom: 20px;
  right: 20px;
  z-index: 1050;
  display: flex;
  flex-direction: column;
  gap: 10px;
}
.toast {
  display: flex;
  align-items: center;
  gap: 10px;
  background: var(--panel);
  color: var(--ink);
  padding: 12px 16px;
  border-radius: var(--radius);
  box-shadow: var(--shadow);
  border: 1px solid var(--border);
  transform: translateX(calc(100% + 20px));
  opacity: 0;
  transition: transform 0.4s cubic-bezier(0.25, 0.8, 0.25, 1), opacity 0.4s;
  min-width: 280px;
  max-width: 350px;
}
.toast.show {
  transform: translateX(0);
  opacity: 1;
}
.toast.hide {
  transform: translateX(calc(100% + 20px));
  opacity: 0;
}
.toast-icon {
  font-size: 20px;
  line-height: 1;
}
.toast-message {
  flex-grow: 1;
  font-size: 14px;
}
.toast.success { border-left: 4px solid #10b981; }
.toast.error { border-left: 4px solid #f43f5e; }
.toast.info { border-left: 4px solid #3b82f6; }
.toast.success .toast-icon { color: #10b981; }
.toast.error .toast-icon { color: #f43f5e; }
.toast.info .toast-icon { color: #3b82f6; }

/* Motion preferences */
@media (prefers-reduced-motion: reduce){
  *{animation:none !important; transition:none !important}
}

mark {
  background: linear-gradient(135deg, #ffeb3b, #fdd835);
  color: #333;
  padding: 1px 3px;
  border-radius: 3px;
  font-weight: 500;
  box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
  border: 1px solid rgba(255, 193, 7, 0.3);
}

/* Screen-reader only */
.sr-only{position:absolute;width:1px;height:1px;padding:0;margin:-1px;overflow:hidden;clip:rect(0,0,0,0);white-space:nowrap;border:0;}

</style>
<style>
  /* Sidebar */
  body {
    display: flex;
  }
  .sidebar {
    width: 260px;
    background: #eef2f9;
    border-right: 1px solid var(--border);
    padding: var(--s-5);
    display: flex;
    flex-direction: column;
    gap: var(--s-4);
    transition: width 0.3s ease, padding 0.3s ease;
    overflow-y: auto;
    height: 100vh;
    position: sticky;
    top: 0;
  }
  .sidebar.collapsed {
    width: 60px;
    padding: var(--s-5) var(--s-2);
    align-items: center;
  }
  .sidebar.collapsed .sidebar-header {
    justify-content: center;
  }
  .sidebar-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
  }
.sidebar.collapsed .sidebar-header h3,
.sidebar.collapsed #manageHistoryBtn {
    display: none;
}
.sidebar.collapsed .sidebar-header {
    justify-content: center;
}
  .sidebar.collapsed .sidebar-header h3,
  .sidebar.collapsed .history-item .details,
  .sidebar.collapsed .sidebar-search,
  .sidebar.collapsed .history-item .meta,
  .sidebar.collapsed .history-item .actions {
    display: none;
  }
  .sidebar-search {
    padding: 0 var(--s-2) var(--s-3);
  }
  #history-search {
    width: 100%;
    padding: var(--s-3);
    border-radius: var(--radius-xs);
    border: 1px solid var(--border);
    background: var(--panel);
  }
  #sidebar-toggle {
    background: transparent;
    border: none;
    font-size: 24px;
    cursor: pointer;
  }
  #history-list {
    list-style: none;
    padding: 0;
    margin: 0;
    display: flex;
    flex-direction: column;
    gap: var(--s-3);
  }
  .history-item {
    background: var(--panel);
    border: 1px solid var(--border);
    border-radius: var(--radius); /* Larger radius */
    padding: var(--s-5); /* More padding */
    transition: all 0.2s ease;
    display: flex;
    flex-direction: column; /* Stack content vertically */
    gap: var(--s-3);
    box-shadow: 0 2px 8px rgba(0,0,0,0.04);
    position: relative;
  }
  .history-item:hover {
    border-color: var(--accent);
    box-shadow: 0 4px 12px rgba(37, 99, 235, 0.1);
    transform: translateY(-2px);
  }
  .history-item.active {
    border-color: var(--accent);
    background: color-mix(in oklab, var(--accent) 8%, transparent);
  }
  .history-item { cursor: pointer; }
  .history-item:focus-visible {
    outline: 2px solid color-mix(in oklab, var(--accent) 80%, white 20%);
    outline-offset: 2px;
  }
  .history-item .name {
    font-weight: 600;
    font-size: var(--fs-1);
    color: var(--ink);
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }
  .sidebar.collapsed .history-item .name {
    display: none;
  }
  .sidebar.collapsed .history-item {
    display: flex;
    align-items: center;
    justify-content: center;
    min-height: 44px;
    padding: var(--s-4);
  }
  .sidebar.collapsed #history-list {
    align-items: center;
  }
  .sidebar.collapsed .history-item::before {
    content: attr(data-tooltip);
    position: absolute;
    left: 100%;
    top: 50%;
    transform: translateY(-50%);
    background: rgba(15, 23, 42, 0.95);
    color: white;
    padding: 6px 10px;
    border-radius: 6px;
    font-size: 13px;
    white-space: nowrap;
    margin-left: 12px;
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.2s 0.1s; /* Delay tooltip appearance */
    z-index: 1001;
  }
  .sidebar.collapsed .history-item:hover::before,
  .sidebar.collapsed .history-item:focus::before,
  .sidebar.collapsed .history-item:focus-visible::before,
  .sidebar.collapsed .history-item:focus-within::before {
    opacity: 1;
  }
  .sidebar.collapsed .history-item::after {
    content: '📄';
    font-size: 18px;
    line-height: 1;
  }
  .sidebar.collapsed .history-item.active {
    border-color: var(--accent);
    box-shadow: 0 0 0 2px color-mix(in oklab, var(--accent) 40%, transparent);
    background: color-mix(in oklab, var(--accent) 8%, transparent);
  }
  .history-item .meta {
    font-size: 0.8rem;
    color: var(--muted);
    display: flex;
    flex-wrap: wrap;
    gap: var(--s-4);
  }
  .history-item .meta span {
    display: inline-flex;
    align-items: center;
    gap: var(--s-2);
  }
  .history-item .actions {
    display: flex;
    gap: var(--s-3);
    margin-top: var(--s-3);
  }
  .history-item .load-btn {
    flex-grow: 1;
    background: var(--accent);
    color: white;
    border: none;
    padding: var(--s-3) var(--s-4);
    border-radius: var(--radius-xs);
    cursor: pointer;
    text-align: center;
    font-weight: 500;
    transition: background 0.2s ease;
  }
  .history-item .load-btn:hover {
    background: color-mix(in oklab, var(--accent) 85%, black);
  }
  .main-content {
    flex-grow: 1;
    height: 100vh;
    overflow-y: auto;
  }
</style>
</head>
<body>
<nav id="sidebar" class="sidebar" aria-label="History sidebar">
  <div class="sidebar-header">
    <h3>History</h3>
    <button id="sidebar-toggle" title="Toggle sidebar" aria-controls="sidebar" aria-expanded="true">☰</button>
    <button id="manageHistoryBtn" title="Manage history" class="tooltip" data-tooltip="Manage history" aria-label="Manage history">⚙️</button>
  </div>
  <div class="sidebar-search">
    <input type="text" id="history-search" placeholder="Search reports..." />
  </div>
  <ul id="history-list" role="listbox" aria-label="Saved reports"></ul>
</nav>
<main id="main-content" class="main-content">
<div class="wrap">
  <div class="section">
    <h2 style="margin:2px 0 10px">CSV → Aggregates (Card UI) + Raw Data Table</h2>
    <div class="bar">
      <input id="file" type="file" accept=".csv,.txt" />
      <button id="loadBtn">Load CSV</button>
      <button id="updateReportBtn" disabled>Update Report</button>
      <button id="saveAsNewBtn" disabled>Save as New</button>
      <span id="meta" class="muted"></span>
    </div>
    <div class="bar" style="margin-top:8px">
      <label>Delimiter:
        <span class="tooltip tooltip-wide" data-tooltip="Character that separates values in your CSV. Auto-detection usually works best. Override if parsing looks incorrect."></span>
        <select id="delimiter">
          <option value="auto">Auto</option>
          <option value=",">Comma (,)</option>
          <option value=";">Semicolon (;)</option>
          <option value="\t">Tab (\t)</option>
          <option value="|">Pipe (|)</option>
        </select>
      </label>
      <label><input id="hasHeader" type="checkbox" checked /> First row has headers
        <span class="tooltip tooltip-wide" data-tooltip="Check if your CSV's first row contains column names instead of data. Usually enabled for standard CSV files."></span>
      </label>

      <label class="tag">
        Mode:
        <span class="tooltip tooltip-wide" data-tooltip="Auto: Uses AI-like detection to automatically assign column roles and generate aggregates. Manual: Allows you to override column roles and add custom aggregates.">
        </span>
        <select id="mode">
          <option value="auto" selected>Auto</option>
          <option value="manual">Manual</option>
        </select>
      </label>
      <button id="editRolesBtn" style="display:none">Edit column roles 
        <span class="tooltip tooltip-wide" data-tooltip="Override automatic column role detection. Change how columns are classified: metric (numbers for calculation), dimension (categories for grouping), date, id, or ignore."></span>
      </button>
      <button id="addAggBtn" style="display:none">Add aggregate
        <span class="tooltip" data-tooltip="Create custom aggregations by selecting specific groupBy and metric combinations."></span>
      </button>
      <button id="clearManualBtn" style="display:none">Clear manual
        <span class="tooltip" data-tooltip="Reset all manual overrides and return to automatic mode."></span>
      </button>
      <button id="recalcBtn" style="display:none">Recalculate with roles
        <span class="tooltip" data-tooltip="Regenerate aggregates using current role assignments."></span>
      </button>

      <button id="autoBtn">Generate Cards
        <span class="tooltip tooltip-wide" data-tooltip="Automatically analyze your CSV data and create up to 10 interactive charts and data tables based on detected patterns and relationships."></span>
      </button>
      <span class="tag">Up to 10 aggregates</span>
    </div>
  </div>

  <div class="section">
    <h3 style="margin:2px 0 10px">Schema / Parser Info</h3>
    <pre id="schema" class="muted" style="white-space:pre-wrap;margin:0"></pre>
  </div>

  <div class="section">
    <h3 style="margin:2px 0 10px">Raw Data</h3>
    <div class="table-controls">
      <label>Search: <input id="searchInput" type="text" placeholder="type to filter across all columns" style="min-width:260px"></label>
      <label>Rows per page:
        <select id="rowsPerPage">
          <option>10</option>
          <option selected>25</option>
          <option>50</option>
          <option>100</option>
        </select>
      </label>
      <div class="pager">
        <button id="prevPage">Prev</button>
        <span class="count" id="pageInfo">Page 1 / 1</span>
        <button id="nextPage">Next</button>
      </div>
      <span class="count" id="rowInfo">Showing 0–0 of 0</span>
      <button id="downloadFiltered">Download filtered CSV</button>
    </div>
    <div class="data-table-wrap">
      <table id="dataTable">
        <thead id="dataThead"></thead>
        <tbody id="dataTbody"></tbody>
        <tfoot id="dataTFoot"></tfoot>
      </table>
    </div>
  </div>

  <div class="section">
    <h3 style="margin:2px 0 10px">Aggregates</h3>
    <div id="results" class="grid"></div>
  </div>
</div>

<!-- Role Editor Modal -->
<div id="roleModal" class="modal" role="dialog" aria-modal="true" aria-hidden="true">
  <div class="modal-card">
    <div class="modal-head">
      <h3>Column Roles</h3>
      <button id="closeRoleModal" aria-label="Close">Close</button>
    </div>
    <table class="role-table">
      <thead><tr><th>Column</th><th>Detected Type</th><th>Unique</th><th>Role</th><th>Sample</th></tr></thead>
      <tbody id="roleTBody"></tbody>
    </table>
    <div style="margin-top:10px;display:flex;gap:8px;flex-wrap:wrap;align-items:center">
      <button id="saveRoles">Save roles</button>
      <div class="help-text">
        <strong>Role Definitions:</strong><br>
        <b>metric</b> - Numeric columns for calculations (sum, avg, count)<br>
        <b>dimension</b> - Categories for grouping (text with limited unique values)<br>
        <b>date</b> - Time-based fields for time series analysis<br>
        <b>id</b> - Unique identifiers (excluded from aggregations)<br>
        <b>ignore</b> - Columns to exclude from all processing
      </div>
    </div>
  </div>
</div>

<!-- Add Aggregate Modal -->
<div id="aggModal" class="modal" role="dialog" aria-modal="true" aria-hidden="true">
  <div class="modal-card">
    <div class="modal-head">
      <h3>Add Aggregate</h3>
      <button id="closeAggModal" aria-label="Close">Close</button>
    </div>
    <div class="bar">
      <label>Group by:
        <span class="tooltip" data-tooltip="Column to group data by (dimension or date columns)"></span>
        <select id="aggGroupBy"></select>
      </label>
      <label>Date bucket:
        <span class="tooltip tooltip-wide" data-tooltip="For date columns, group dates into time periods. Leave empty for exact dates."></span>
        <select id="aggBucket">
          <option value="">(none)</option>
          <option value="day">day</option>
          <option value="week">week</option>
          <option value="month">month</option>
          <option value="quarter">quarter</option>
          <option value="year">year</option>
        </select>
      </label>
      <label>Metric:
        <span class="tooltip" data-tooltip="Numeric column to aggregate (metric columns only)"></span>
        <select id="aggMetric"></select>
      </label>
      <label>Function:
        <span class="tooltip tooltip-wide" data-tooltip="sum: Add all values | avg: Calculate average | count: Count non-null values | min/max: Find minimum/maximum values | distinct_count: Count unique values"></span>
        <select id="aggFunc">
          <option value="sum">sum</option>
          <option value="avg">avg</option>
          <option value="min">min</option>
          <option value="max">max</option>
          <option value="count">count</option>
          <option value="distinct_count">distinct_count</option>
        </select>
      </label>
    </div>
    <div class="bar" style="margin-top:8px">
      <label>Chart:
        <span class="tooltip tooltip-wide" data-tooltip="Auto: System chooses best chart based on data. Bar: Good for categories. Line/Area: Best for time series. Pie/Doughnut: Good for proportions of a whole."></span>
        <select id="aggChart">
          <option value="auto">Auto</option>
          <option value="bar">Bar (vertical)</option>
          <option value="hbar">Bar (horizontal)</option>
          <option value="line">Line</option>
          <option value="area">Area</option>
          <option value="pie">Pie</option>
          <option value="doughnut">Doughnut</option>
          <option value="polarArea">Polar Area</option>
          <option value="radar">Radar</option>
        </select>
      </label>
      <label>Top-N:
        <span class="tooltip tooltip-wide" data-tooltip="Limit pie/doughnut charts to top N categories by value. Remaining items grouped as 'Others'. Helps with readability when there are many small categories."></span>
        <input id="aggTopN" type="number" min="3" max="999" value="20" style="width:90px" />
        <span class="muted small" style="display:block">Max items for pie/doughnut charts (3-999, default: 20)</span>
      </label>
      <button id="addAggConfirm">Add</button>
    </div>
    <div class="help-text">
      <strong>Tips:</strong> 
      • Use date columns with time buckets for time series analysis
      • Combine categories (dimensions) with numeric metrics for comparison charts  
      • Count function works with any column type for frequency analysis
      • Try different chart types to find the best visualization for your data
    </div>
  </div>
</div>

<!-- History Management Modal -->
<div id="historyModal" class="modal" role="dialog" aria-modal="true" aria-hidden="true">
  <div class="modal-card">
    <div class="modal-head">
      <h3>Manage History</h3>
      <button id="closeHistoryModal" aria-label="Close">Close</button>
    </div>
    <div style="display: flex; align-items: center; gap: 8px; padding: 8px; border-bottom: 1px solid var(--border);">
      <input type="checkbox" id="history-select-all" />
      <label for="history-select-all">Select All</label>
    </div>
    <div id="history-management-list" style="display: flex; flex-direction: column; gap: 8px; margin-bottom: 16px; padding-top: 8px;">
      <!-- History items will be populated here -->
    </div>
    <div class="card-foot" style="justify-content: space-between;">
      <button id="deleteSelectedBtn" disabled style="background: #fca5a5; color: #7f1d1d; border: 1px solid #f87171;">Delete Selected</button>
      <button id="clearAllHistoryBtn" style="background: #ef4444; color: white; border: none;">Clear All History</button>
    </div>
  </div>
</div>

<div id="toast-container" class="toast-container"></div>
<div id="sr-announcer" class="sr-only" aria-live="polite" aria-atomic="true"></div>

<script type="module">
import * as Store from './store.js';
/* ========= utils ========= */
const $ = s => document.querySelector(s);
const stripBOM = s => (s && s.charCodeAt(0) === 0xFEFF) ? s.slice(1) : s;
function showToast(message, type = 'info', duration = 3000, toastId = null) {
  const container = $('#toast-container');
  if (!container) return;

  let toast;
  if (toastId) {
    toast = container.querySelector(`[data-toast-id="${toastId}"]`);
  }

  if (toast) {
    // Update existing toast
    toast.className = `toast ${type} show`;
    toast.querySelector('.toast-message').textContent = message;
  } else {
    // Create new toast
    toast = document.createElement('div');
    toast.className = `toast ${type}`;
    if (toastId) {
      toast.setAttribute('data-toast-id', toastId);
    }

    const icon = document.createElement('span');
    icon.className = 'toast-icon';
    if (type === 'success') icon.textContent = '✓';
    else if (type === 'error') icon.textContent = '✗';
    else icon.textContent = 'ℹ';

    const msg = document.createElement('span');
    msg.className = 'toast-message';
    msg.textContent = message;

    toast.append(icon, msg);
    container.appendChild(toast);

    requestAnimationFrame(() => {
      toast.classList.add('show');
    });
  }

  // Clear any existing timeout
  const existingTimeout = toast.dataset.timeoutId;
  if (existingTimeout) {
    clearTimeout(existingTimeout);
  }

  // Set new timeout to remove
  if (duration > 0) {
    const timeoutId = setTimeout(() => {
      toast.classList.remove('show');
      toast.classList.add('hide');
      toast.addEventListener('transitionend', () => {
        try {
          container.removeChild(toast);
        } catch {}
      }, { once: true });
    }, duration);
    toast.dataset.timeoutId = timeoutId;
  }
}

function getFormattedDateTime() {
  const now = new Date();
  const year = now.getFullYear();
  const month = String(now.getMonth() + 1).padStart(2, '0');
  const day = String(now.getDate()).padStart(2, '0');
  const hours = String(now.getHours()).padStart(2, '0');
  const minutes = String(now.getMinutes()).padStart(2, '0');
  return `${year}-${month}-${day} ${hours}:${minutes}`;
}

// Number parsing: handle commas, dots, percents, spaces
function toNumLocale(v){
  let s = String(v ?? '').trim();
  if (!s) return NaN;
  const pct = /%$/.test(s);
  s = s.replace(/\s/g,'');
  // Detect European style 1.234,56 vs US 1,234.56
  const hasComma = s.includes(',');
  const hasDot = s.includes('.');
  if (hasComma && hasDot){
    // assume the last separator is decimal
    if (s.lastIndexOf(',') > s.lastIndexOf('.')){
      s = s.replace(/\./g,'').replace(/,/g,'.');
    } else {
      s = s.replace(/,/g,'');
    }
  } else if (hasComma && !hasDot){
    // likely decimal comma
    s = s.replace(/,/g,'.');
  } else {
    // plain or US style, remove thousands commas
    s = s.replace(/,/g,'');
  }
  s = s.replace(/%$/,'');
  const n = Number(s);
  if (!isFinite(n)) return NaN;
  return pct ? n/100 : n;
}
const isNum = v => { const n = toNumLocale(v); return !Number.isNaN(n) && isFinite(n); };
const toNum = v => toNumLocale(v);
const nice = n => { if (n==null || isNaN(n)) return ''; const a=Math.abs(n);
  if (a>=1e9) return (n/1e9).toFixed(1)+'B';
  if (a>=1e6) return (n/1e6).toFixed(1)+'M';
  if (a>=1e3) return (n/1e3).toFixed(1)+'K';
  return String(Number((+n).toFixed(2)));
};
function debounce(fn, ms=250){ let t; return (...args)=>{ clearTimeout(t); t=setTimeout(()=>fn(...args), ms); }; }

// Debounced auto-save function
const debouncedAutoSave = debounce(() => {
  if (!window.currentHistoryId || !ROWS) return;
  const currentName = $('#history-list .history-item[data-id="' + window.currentHistoryId + '"] .name')?.textContent || 'current report';
  console.log(`Auto-saving changes to "${currentName}"...`);
  saveCurrentStateToHistory(currentName, false); // false = update existing
}, 1500);

/* ========= safer date parsing ========= */
function parseDateSafe(v){
  if (!v) return NaN;
  const s = String(v).trim();
  if (/^\d{4}-\d{2}-\d{2}/.test(s)) {
    // Parse ISO date format (YYYY-MM-DD) as UTC
    const [, year, month, day] = s.match(/^(\d{4})-(\d{2})-(\d{2})/);
    if (year && month && day) {
      return Date.UTC(+year, +month-1, +day);
    }
  }
  // Handle DD/MM/YY or DD/MM/YYYY formats
  const m = /^(\d{1,2})\/(\d{1,2})\/(\d{2,4})$/.exec(s);
  if (m) {
    // For DD/MM/YY format, assume 20xx for years 00-49 and 19xx for years 50-99
    let year = +m[3];
    if (year < 100) {
      year = year < 50 ? 2000 + year : 1900 + year;
    }
    return Date.UTC(year, +m[2]-1, +m[1]);
  }
  const u = Date.parse(s);
  return isNaN(u) ? NaN : u; // leave as-is for other variants
}

/* ========= state ========= */
let ROWS=null, PROFILE=null, LAST_PARSE_META=null;
let DATA_COLUMNS=[], FILTERED_ROWS=[], PAGE=1, RPP=25, QUERY="";
let SORT = { col:null, dir:'asc' };

let MODE = 'auto';
let MANUAL_ROLES = {};   // { colName: 'dimension'|'metric'|'date'|'id'|'ignore' }
let MANUAL_JOBS  = [];   // [{groupBy, metric, agg, chart, topN, dateBucket?}]

/* ========= persistence ========= */
function signatureFromHeaders(){
  if (!DATA_COLUMNS.length) return '';
  return DATA_COLUMNS.join('|') + '::' + (ROWS?ROWS.length:0);
}
const STORAGE_KEY = 'csv-agg-state-v2';
function saveState(){
  try{
    const key = signatureFromHeaders();
    localStorage.setItem(STORAGE_KEY, JSON.stringify({ MODE, MANUAL_ROLES, MANUAL_JOBS, key }));
  }catch{}
}
function loadState(){
  try{
    const raw = localStorage.getItem(STORAGE_KEY); if (!raw) return;
    const s = JSON.parse(raw);
    if (s.key && s.key === signatureFromHeaders()){
      MODE = s.MODE || MODE; MANUAL_ROLES = s.MANUAL_ROLES || {}; MANUAL_JOBS = s.MANUAL_JOBS || [];
      $('#mode').value = MODE; switchMode(MODE);
    }
  }catch{}
}
['change','click','input'].forEach(ev=>{ document.addEventListener(ev, debounce(saveState, 300), true); });

/* ========= parsing with smart delimiter + worker + progress ========= */
async function sniffText(file, bytes=256*1024){ const blob = await file.slice(0, bytes).text(); return stripBOM(blob || ''); }
function tryParsePreview(text, opt){
  return Papa.parse(text, { header: !!opt.header, preview: 25, skipEmptyLines: 'greedy', delimiter: opt.delimiter ?? "", quoteChar: '"', escapeChar: '"' });
}
function scorePreview(res){ const rows = res.data || []; const lens = rows.map(r => Array.isArray(r) ? r.length : (typeof r==='object' ? Object.keys(r).length : 0)); const modal = lens.length ? mode(lens) : 0; const err = (res.errors || []).length; return { modalCols: modal, errors: err }; }
function mode(arr){ const m=new Map(); let best=0, v=0; for(const x of arr){const c=(m.get(x)||0)+1; m.set(x,c); if(c>best){best=c; v=x}} return v; }
async function autoDetect(file, header=true){
  const text = await sniffText(file);
  const candidates = [",",";","\t","|"];
  let best = { delimiter:",", score:{modalCols:0, errors:Infinity} };
  for (const d of candidates){
    const res = tryParsePreview(text, { delimiter:d, header });
    const s = scorePreview(res);
    const better = (s.modalCols > best.score.modalCols) || (s.modalCols===best.score.modalCols && s.errors < best.score.errors);
    if (better) best = { delimiter:d, score:s };
  }
  return best;
}
async function parseCSV(file, delimiterChoice, header=true){
  // Validate input file
  if (!file || !file.size) {
    throw new Error('No file selected or file is empty');
  }
  
  let delimiter = ",";
  if (delimiterChoice === 'auto'){
    try {
      const autod = await autoDetect(file, header);
      delimiter = autod.delimiter;
    } catch (err) {
      console.warn('Auto-detection failed, using comma:', err);
      delimiter = ",";
    }
  } else {
    // accept either "\t" or actual tab character
    delimiter = (delimiterChoice === '\t' || delimiterChoice === '	') ? '	' : delimiterChoice;
  }
  
  $('#meta').textContent = `Parsing… (worker) delim="${delimiter}"`;
  console.log('Starting parse with config:', { customWorker: true, header, delimiter, fileSize: file.size, fileName: file.name });
  
  return new Promise((resolve,reject)=>{
    let rowCount = 0;
    let hasCalledComplete = false;
    let isUsingWorker = true; // Track if we're using worker mode
    // Collect rows when using step() so we still return full data on complete
    const collectedRows = [];
    
    // Set up a timeout to detect if parsing gets stuck
    const timeout = setTimeout(() => {
      if (!hasCalledComplete) {
        console.error('Parse timeout - no response from parser (non-fatal, will rely on internal fallbacks)');
        // Do not reject here; worker/onerror handler will manage fallback/termination.
      }
    }, 30000); // 30 second timeout
    
    const completeHandler = (results)=>{
      if (hasCalledComplete) {
        console.warn('Complete callback called multiple times, ignoring');
        return;
      }
      hasCalledComplete = true;
      clearTimeout(timeout);
      
      console.log('Parse complete callback received:', results, 'isUsingWorker:', isUsingWorker);
      
      try {
        if (!results) {
          console.error('Results is null/undefined');
          
          // If this was the worker mode and we haven't tried fallback yet, try non-worker mode
          if (isUsingWorker) {
            console.log('Worker returned undefined, trying non-worker fallback...');
            hasCalledComplete = false; // Reset flag for retry
            isUsingWorker = false; // Mark that we're now trying non-worker
            
            const fallbackConfig = { 
              worker: false,
              header,
              skipEmptyLines:'greedy',
              dynamicTyping:false,
              delimiter,
              quoteChar:'"',
              escapeChar:'"',
              step: (results)=>{
                rowCount++;
                // Accumulate streamed row from step() so complete can return full dataset
                if (results && 'data' in results) collectedRows.push(results.data);
                if ((rowCount % 1000)===0) $('#meta').textContent = `Parsing… ${rowCount.toLocaleString()} rows (fallback)`;
              },
              complete: completeHandler,
              error: errorHandler
            };
            
            try {
              Papa.parse(file, fallbackConfig);
              return; // Don't reject yet, wait for fallback
            } catch (fallbackErr) {
              console.error('Fallback parse failed to start:', fallbackErr);
              reject(new Error('Both worker and non-worker parsing failed to start'));
              return;
            }
          }
          
          reject(new Error('Parser returned no result - both worker and non-worker modes failed'));
          return;
        }
        
        if (typeof results !== 'object') {
          console.error('Results is not an object:', typeof results, results);
          reject(new Error('Parser returned invalid result type: ' + typeof results));
          return;
        }
        
        // Ensure we have valid data structure; when using step(), results.data is empty, so use collectedRows
        let data = (results.data && Array.isArray(results.data)) ? results.data : [];
        let meta = (results.meta && typeof results.meta === 'object') ? results.meta : {};
        let errors = (results.errors && Array.isArray(results.errors)) ? results.errors : [];
        if (!data.length && collectedRows.length) {
          // collectedRows contains per-row objects/arrays from step()
          data = collectedRows;
        }
        // Ensure delimiter is present in meta for later UI
        if (!meta || typeof meta !== 'object') meta = {};
        if (!('delimiter' in meta)) meta.delimiter = delimiter;
        
        console.log('Parsed data summary:', { dataRows: data.length, metaKeys: Object.keys(meta), errorCount: errors.length });
        
        LAST_PARSE_META = meta;
        $('#meta').textContent = `Parsed ${data.length.toLocaleString()} rows`;
        
        // Check for parsing errors first
        if (errors.length > 0) {
          console.warn('Parse errors:', errors);
          if (!data.length) {
            reject(new Error(errors[0]?.message || 'Parse failed with errors'));
            return;
          }
        }
        
        if (!data.length) {
          reject(new Error('No rows parsed - check file format and delimiter'));
          return;
        }
        
        resolve({ data, meta, errors });
      } catch (err) {
        console.error('Error in complete callback:', err);
        reject(new Error('Error processing parse results: ' + (err.message || err)));
      }
    };
    
    const errorHandler = (err, file, inputElem, reason)=>{
      clearTimeout(timeout);
      console.error('PapaParse error callback:', { err, file, inputElem, reason });
      reject(err || new Error(reason || 'Unknown parse error'));
    };

    try {
      // Prefer self-hosted worker to avoid cross-origin worker issues
      const worker = new Worker('parser.worker.js');
      isUsingWorker = true;
      const workerTimeout = setTimeout(()=>{
        console.error('Worker timeout - switching to non-worker fallback');
        try{ worker.terminate(); }catch{}
        // Start fallback
        const fallbackConfig = {
          worker: false,
          header,
          skipEmptyLines:'greedy',
          dynamicTyping:false,
          delimiter,
          quoteChar:'"',
          escapeChar:'"',
          step: (results)=>{
            rowCount++;
            if (results && 'data' in results) collectedRows.push(results.data);
            if ((rowCount % 1000)===0) $('#meta').textContent = `Parsing… ${rowCount.toLocaleString()} rows (fallback)`;
          },
          complete: completeHandler,
          error: errorHandler
        };
        try{ Papa.parse(file, fallbackConfig); }catch(fallbackErr){
          console.error('Fallback parse failed to start after worker timeout:', fallbackErr);
          reject(new Error('Both worker and non-worker parsing failed to start'));
        }
      }, 30000);
      
      worker.onmessage = (e)=>{
        clearTimeout(workerTimeout);
        if (!e || !e.data){
          console.warn('Worker sent empty message; falling back');
          const fallbackConfig = {
            worker: false,
            header,
            skipEmptyLines:'greedy',
            dynamicTyping:false,
            delimiter,
            quoteChar:'"',
            escapeChar:'"',
            step: (results)=>{
              rowCount++;
              if (results && 'data' in results) collectedRows.push(results.data);
              if ((rowCount % 1000)===0) $('#meta').textContent = `Parsing… ${rowCount.toLocaleString()} rows (fallback)`;
            },
            complete: completeHandler,
            error: errorHandler
          };
          try{ Papa.parse(file, fallbackConfig); }catch(fallbackErr){
            console.error('Fallback parse failed to start:', fallbackErr);
            reject(new Error('Both worker and non-worker parsing failed to start'));
          }
          return;
        }
        const msg = e.data;
        if (msg.error){
          console.warn('Worker error:', msg.message);
          const fallbackConfig = {
            worker: false,
            header,
            skipEmptyLines:'greedy',
            dynamicTyping:false,
            delimiter,
            quoteChar:'"',
            escapeChar:'"',
            step: (results)=>{
              rowCount++;
              if (results && 'data' in results) collectedRows.push(results.data);
              if ((rowCount % 1000)===0) $('#meta').textContent = `Parsing… ${rowCount.toLocaleString()} rows (fallback)`;
            },
            complete: completeHandler,
            error: errorHandler
          };
          try{ Papa.parse(file, fallbackConfig); }catch(fallbackErr){
            console.error('Fallback parse failed to start:', fallbackErr);
            reject(new Error('Both worker and non-worker parsing failed to start'));
          }
          return;
        }
        // Optional progress support if worker posts {progress}
        if ('progress' in msg){
          $('#meta').textContent = `Parsing… ${Number(msg.progress||0).toLocaleString()} rows (worker)`;
          return;
        }
        // Normal completion path
        try{
          const results = { data: Array.isArray(msg.data)?msg.data:[], meta: msg.meta||{}, errors: Array.isArray(msg.errors)?msg.errors:[] };
          completeHandler(results);
        } finally {
          try{ worker.terminate(); }catch{}
        }
      };
      
      worker.onerror = (err)=>{
        clearTimeout(workerTimeout);
        console.error('Worker onerror:', err?.message || err);
        const fallbackConfig = {
          worker: false,
          header,
          skipEmptyLines:'greedy',
          dynamicTyping:false,
          delimiter,
          quoteChar:'"',
          escapeChar:'"',
          step: (results)=>{
            rowCount++;
            if (results && 'data' in results) collectedRows.push(results.data);
            if ((rowCount % 1000)===0) $('#meta').textContent = `Parsing… ${rowCount.toLocaleString()} rows (fallback)`;
          },
          complete: completeHandler,
          error: errorHandler
        };
        try{ Papa.parse(file, fallbackConfig); }catch(fallbackErr){
          console.error('Fallback parse failed to start after worker error:', fallbackErr);
          reject(new Error('Both worker and non-worker parsing failed to start'));
        }
      };
      
      const workerConfig = {
        header,
        skipEmptyLines:'greedy',
        dynamicTyping:false,
        delimiter,
        quoteChar:'"',
        escapeChar:'"'
      };
      worker.postMessage({ file, config: workerConfig });
    } catch (err) {
      clearTimeout(timeout);
      console.error('Error starting custom worker:', err);
      const fallbackConfig = {
        worker: false,
        header,
        skipEmptyLines:'greedy',
        dynamicTyping:false,
        delimiter,
        quoteChar:'"',
        escapeChar:'"',
        step: (results)=>{
          rowCount++;
          if (results && 'data' in results) collectedRows.push(results.data);
          if ((rowCount % 1000)===0) $('#meta').textContent = `Parsing… ${rowCount.toLocaleString()} rows (fallback)`;
        },
        complete: completeHandler,
        error: errorHandler
      };
      try{ Papa.parse(file, fallbackConfig); }catch(fallbackErr){
        console.error('Fallback parse failed to start after worker constructor error:', fallbackErr);
        reject(new Error('Both worker and non-worker parsing failed to start'));
      }
    }
  });
}

/* ========= profiling ========= */
function inferType(v){
  if (v==null || v==='') return 'empty';
  if (isNum(v)) return 'number';
  const t = parseDateSafe(v);
  if (!Number.isNaN(t)) return 'date';
  return 'string';
}
function profile(rows){
  const cols = Object.keys(rows[0]||{});
  const sample = rows.slice(0, Math.min(500, rows.length));
  const out = cols.map(name=>{
    const vals = sample.map(r=>r[name]);
    const counts = {number:0,date:0,string:0};
    for (const v of vals){ const t=inferType(v); counts[t]=(counts[t]||0)+1; }
    const type = Object.entries(counts).sort((a,b)=>b[1]-a[1])[0][0];
    const uniq = new Set(vals.filter(x=>x!=null&&x!=='').map(String)).size;
    const samples = vals.filter(x=>x!=null&&x!=='').slice(0,3).map(String);
    return { name, type, unique: uniq, samples };
  });
  return { columns: out, rowCount: rows.length };
}
function renderProfile(p){
  const lines = p.columns.map(c=>`${c.name} — ${c.type} · unique=${c.unique} · samples=[${c.samples.join(', ')}]`);
  const meta = LAST_PARSE_META ? `\nmeta: delimiter="${LAST_PARSE_META.delimiter}" linebreak="${LAST_PARSE_META.linebreak}"` : '';
  $('#schema').textContent = `rows=${p.rowCount}\n` + lines.join('\n') + meta;
}

/* ========= raw data table: header, sorting, filter, pagination, tfoot sums ========= */
function isLikelyCodeColumn(name){ return /(code|id|sku|account|acct|phone|tel|zip|postal|nr|no|number)$/i.test(String(name).trim()); }
function columnType(name){ const c = PROFILE?.columns?.find(x=>x.name===name); return c ? c.type : 'string'; }
function buildRawHeader(columns){
  const thead = $('#dataThead'); thead.innerHTML='';
  const tr = document.createElement('tr');
  columns.forEach(col=>{
    const th=document.createElement('th'); th.className='sticky'; th.textContent=col;
    const s = document.createElement('span'); s.className='sort'; s.textContent='';
    th.appendChild(s);
    th.addEventListener('click', ()=>{
      if (SORT.col===col){ SORT.dir = (SORT.dir==='asc'?'desc':'asc'); }
      else { SORT.col=col; SORT.dir='asc'; }
      renderSortIndicators(); renderRawBody();
    });
    tr.appendChild(th);
  });
  thead.appendChild(tr);
  renderSortIndicators();
}
function renderSortIndicators(){
  const ths = Array.from($('#dataThead').querySelectorAll('th'));
  ths.forEach(th=>{
    const col = th.firstChild?.nodeValue || th.childNodes[0]?.textContent || '';
    const span = th.querySelector('.sort');
    if (!span) return;
    if (SORT.col===col) span.textContent = SORT.dir==='asc' ? '↑' : '↓';
    else span.textContent = '';
  });
}
function applyFilter(){
  const q = QUERY.trim().toLowerCase();
  if (!q){ FILTERED_ROWS = ROWS; return; }
  FILTERED_ROWS = ROWS.filter(row=>{
    for (const c of DATA_COLUMNS){
      const v = row[c];
      if (v!=null && String(v).toLowerCase().includes(q)) return true;
    }
    return false;
  });
}
function sortRows(rows){
  if (!SORT.col) return rows;
  const name = SORT.col;
  const t = columnType(name);
  const dir = SORT.dir==='asc' ? 1 : -1;
  const cmp = (a,b)=>{
    const av = a[name], bv = b[name];
    if (t==='number'){
      const an = toNum(av), bn = toNum(bv);
      if (isNaN(an) && isNaN(bn)) return 0; if (isNaN(an)) return -dir; if (isNaN(bn)) return dir;
      return an < bn ? -dir : an > bn ? dir : 0;
    } else if (t==='date'){
      const an = parseDateSafe(av), bn = parseDateSafe(bv);
      if (isNaN(an) && isNaN(bn)) return 0; if (isNaN(an)) return -dir; if (isNaN(bn)) return dir;
      return an < bn ? -dir : an > bn ? dir : 0;
    } else {
      const as = (av==null?'':String(av)).toLowerCase();
      const bs = (bv==null?'':String(bv)).toLowerCase();
      return as < bs ? -dir : as > bs ? dir : 0;
    }
  };
  return rows.map((r,i)=>({r,i})).sort((A,B)=> cmp(A.r,B.r) || (A.i - B.i)).map(A=>A.r);
}
function renderTFootSums(){
  const tfoot = $('#dataTFoot'); tfoot.innerHTML='';
  if (!FILTERED_ROWS?.length){ return; }
  const tr = document.createElement('tr');
  DATA_COLUMNS.forEach(col=>{
    const td = document.createElement('td');
    const t = columnType(col);
    if (t==='number' && !isLikelyCodeColumn(col)){
      let sum = 0;
      for (const r of FILTERED_ROWS){ const n = toNum(r[col]); if (!isNaN(n)) sum += n; }
      td.textContent = 'Σ ' + nice(sum);
    } else { td.textContent = ''; }
    tr.appendChild(td);
  });
  tfoot.appendChild(tr);
}
function renderRawBody(){
  const tbody = $('#dataTbody'); tbody.innerHTML='';
  const total = FILTERED_ROWS.length, pages = Math.max(1, Math.ceil(total / RPP));
  PAGE = Math.min(PAGE, pages);
  const sorted = sortRows(FILTERED_ROWS);
  const start = (PAGE-1)*RPP, end = Math.min(start+RPP, total);
  
  // Function to highlight search terms in text
  function highlightText(text, query) {
    if (!query || !query.trim()) return text;
    // Escape HTML in the text first to prevent XSS
    const safeText = String(text).replace(/[&<>"']/g, function(m) {
      return {'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m];
    });
    const escapedQuery = query.trim().replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
    const regex = new RegExp(`(${escapedQuery})`, 'gi');
    return safeText.replace(regex, '<mark>$1</mark>');
  }
  
  for (let i=start;i<end;i++){
    const r = sorted[i];
    const tr = document.createElement('tr');
    DATA_COLUMNS.forEach(c=>{
      const td = document.createElement('td');
      let v = r[c];
      const textValue = (v==null? '' : String(v));
      
      // Apply highlighting if there's a search query
      const searchTerm = QUERY ? QUERY.trim() : '';
      if (searchTerm) {
        td.innerHTML = highlightText(textValue, searchTerm);
      } else {
        td.textContent = textValue;
      }
      
      tr.appendChild(td);
    });
    tbody.appendChild(tr);
  }
  $('#pageInfo').textContent = `Page ${PAGE} / ${pages}`;
  $('#rowInfo').textContent = `Showing ${total? start+1:0}–${end} of ${total}${(ROWS && ROWS.length!==total) ? ` (filtered from ${ROWS.length})` : ''}`;
  $('#prevPage').disabled = PAGE<=1;
  $('#nextPage').disabled = PAGE>=pages;
  renderTFootSums();
}
const onSearch = debounce(()=>{ QUERY = $('#searchInput').value; PAGE=1; applyFilter(); renderRawBody(); }, 200);

/* ========= roles + auto plan (no-AI) ========= */
// Enhanced Pattern Recognition for Business Data Types
const NAME_PATTERNS = {
  // Core metric patterns with expanded business terminology
  metric: /(amount|total|revenue|sales|price|unit[_\s-]*price|cost|profit|margin|rate|percent|%|tax|fee|value|worth|balance|qty|quantity|金额|总额|数量|单价|价格|费|税|值|余额)/i,
  
  // Comprehensive code/ID patterns for ERP/CRM systems
  code: /(code|id|sku|account|acct|ref|reference|key|编号|编码|货号|料号|单号|订单号|客户号|编号$|代码$|no\.?$|number$|num$)/i,
  
  // Enhanced date/time patterns with business contexts
  date: /(date|time|day|month|quarter|year|created|updated|modified|issued|due|expired|日期|时间|月份|季度|年份)/i,
  
  // Financial metrics (highest priority for business data)
  financial: /(amount|total|price|cost|revenue|sales|profit|margin|balance|budget|forecast|target|actual|variance|金额|总额|收入|成本|利润|预算)/i,
  
  // Quantity and measurement patterns
  quantity: /(qty|quantity|count|units|pieces|volume|weight|size|length|width|height|数量|件数|重量|体积)/i,
  
  // Business entity identifiers
  entityId: /(customer[_\s-]*id|client[_\s-]*id|vendor[_\s-]*id|supplier[_\s-]*id|employee[_\s-]*id|product[_\s-]*id|order[_\s-]*id|invoice[_\s-]*id|客户号|供应商号|员工号|产品号)/i,
  
  // Address and location patterns
  location: /(address|street|city|state|province|country|zip|postal|region|territory|location|地址|城市|省份|国家|邮编)/i,
  
  // Contact information patterns
  contact: /(email|phone|tel|mobile|fax|contact|website|url|邮箱|电话|手机|传真|联系)/i,
  
  // Status and category patterns
  status: /(status|state|stage|phase|type|category|class|group|level|priority|rank|状态|类型|分类|等级|优先级)/i,
  
  // Hierarchical relationship patterns
  hierarchy: /(parent|child|level|tier|dept|department|division|team|manager|supervisor|superior|subordinate|上级|下级|部门|团队|经理)/i,
  
  // Temporal series patterns
  temporal: /(period|quarter|month|week|day|fiscal|year|season|cycle|trend|sequence|时期|季度|月份|周|年|趋势)/i
};
const CODE_LIKE_NUM = /(zip|postal|phone|tel|nid|ic|passport|order|invoice|po|so)$/i;

// Enhanced role detection with hierarchical and temporal analysis
function detectHierarchicalRelationships(profile) {
  const relationships = {};
  const columns = profile.columns.map(c => c.name.toLowerCase());
  
  // Look for parent-child relationships
  columns.forEach(colName => {
    if (NAME_PATTERNS.hierarchy.test(colName)) {
      if (colName.includes('parent') || colName.includes('manager') || colName.includes('上级')) {
        const childCol = columns.find(c => 
          (c.includes('child') || c.includes('subordinate') || c.includes('下级')) ||
          c.includes(colName.replace(/parent|manager|上级/g, ''))
        );
        if (childCol) {
          relationships[colName] = { type: 'parent', child: childCol };
          relationships[childCol] = { type: 'child', parent: colName };
        }
      }
    }
  });
  
  return relationships;
}

function detectTemporalPatterns(col, rows) {
  const name = col.name.toLowerCase();
  const isTemporalSeries = NAME_PATTERNS.temporal.test(name);
  
  if (!isTemporalSeries || col.type !== 'string') return null;
  
  // Sample data to detect patterns
  const samples = rows.slice(0, Math.min(100, rows.length)).map(row => row[col.name]).filter(v => v);
  
  // Check for sequential patterns (Q1, Q2, Q3, Q4 or Month1, Month2, etc.)
  const hasSequentialPattern = samples.some(val => 
    /^(q|quarter|month|week|period|season)[_\s-]*\d+$/i.test(val) ||
    /^\d+[_\s-]*(q|quarter|month|week|period|season)$/i.test(val)
  );
  
  // Check for fiscal year patterns (FY2024, 2024Q1, etc.)
  const hasFiscalPattern = samples.some(val =>
    /^(fy|fiscal)[_\s-]*\d{4}$/i.test(val) ||
    /^\d{4}[_\s-]*(q\d|quarter\d)$/i.test(val)
  );
  
  return {
    isSequential: hasSequentialPattern,
    isFiscal: hasFiscalPattern,
    pattern: hasSequentialPattern ? 'sequential' : hasFiscalPattern ? 'fiscal' : 'none'
  };
}

function inferRole(col, profile, rows) {
  const name = col.name || '';
  const type = col.type;
  const uniq = col.unique || 0;
  const rowCount = profile.rowCount || Math.max(1, rows.length);
  const uniqRatio = rowCount ? uniq / rowCount : 0;
  
  // Enhanced pattern matching with priority scoring
  const patterns = {
    financial: NAME_PATTERNS.financial.test(name),
    quantity: NAME_PATTERNS.quantity.test(name),
    entityId: NAME_PATTERNS.entityId.test(name),
    location: NAME_PATTERNS.location.test(name),
    contact: NAME_PATTERNS.contact.test(name),
    status: NAME_PATTERNS.status.test(name),
    hierarchy: NAME_PATTERNS.hierarchy.test(name),
    temporal: NAME_PATTERNS.temporal.test(name),
    code: NAME_PATTERNS.code.test(name),
    date: NAME_PATTERNS.date.test(name),
    metric: NAME_PATTERNS.metric.test(name)
  };
  
  // Detect temporal patterns for enhanced time-series recognition
  const temporalInfo = detectTemporalPatterns(col, rows);
  
  // Date/Time detection with enhanced temporal patterns
  if (type === 'date' || patterns.date || (temporalInfo && temporalInfo.pattern !== 'none')) {
    return { 
      role: 'date', 
      temporal: temporalInfo,
      priority: patterns.temporal ? 'high' : 'normal'
    };
  }
  
  // Enhanced numeric role detection
  if (type === 'number') {
    // Absolute highest priority for 'Amount'
    if (/amount/i.test(name)) return { role: 'metric:strong', category: 'financial', priority: 'critical' };

    // Highest priority: Financial metrics
    if (patterns.financial) return { role: 'metric:strong', category: 'financial', priority: 'high' };
    
    // High priority: Quantity metrics
    if (patterns.quantity) return { role: 'metric:strong', category: 'quantity', priority: 'normal' };
    
    // Standard metrics
    if (patterns.metric) return { role: 'metric:strong', category: 'general', priority: 'normal' };
    
    // ID-like numbers (codes, postal codes, etc.)
    if (patterns.code || patterns.entityId || CODE_LIKE_NUM.test(name)) {
      return { role: 'id', category: 'identifier', priority: 'normal' };
    }
    
    // Default numeric handling
    return { role: 'metric', category: 'general', priority: 'low' };
  }
  
  // Enhanced string role detection
  if (type === 'string') {
    // Entity identifiers (highest priority for IDs)
    if (patterns.entityId) return { role: 'id', category: 'entity', priority: 'high' };
    
    // General codes and IDs
    if (patterns.code) return { role: 'id', category: 'code', priority: 'normal' };
    
    // High uniqueness ratio suggests ID
    if (uniqRatio > 0.95) return { role: 'id', category: 'unique', priority: 'normal' };
    
    // Contact information (special handling for CRM data)
    if (patterns.contact) return { role: 'dimension', category: 'contact', priority: 'high' };
    
    // Location data (important for geographic analysis)
    if (patterns.location) return { role: 'dimension', category: 'location', priority: 'high' };
    
    // Status/Category fields (important for filtering)
    if (patterns.status) return { role: 'dimension', category: 'status', priority: 'high' };
    
    // Hierarchical data (special handling for org charts)
    if (patterns.hierarchy) return { role: 'dimension', category: 'hierarchy', priority: 'high' };
    
    // Temporal categories (quarters, periods, etc.)
    if (patterns.temporal || temporalInfo) {
      return { 
        role: 'dimension', 
        category: 'temporal', 
        priority: 'high',
        temporal: temporalInfo 
      };
    }
    
    // Default string handling
    return { role: 'dimension', category: 'general', priority: 'normal' };
  }
  
  const result = { role: 'ignore', category: 'unknown', priority: 'none' };
  console.log(`[inferRole] Finished ${name}:`, result);
  return result;
}

function pickPrimaryMetric(profile, rows) {
  const numCols = profile.columns.filter(c => c.type === 'number');
  
  // Then look for other strong metrics
  const scored = numCols.map(c => {
    let nameScore = NAME_PATTERNS.metric.test(c.name) ? 2 : 0;
    
    // Give extra points to key financial terms
    if (/amount/i.test(c.name)) nameScore += 8;
    if (/total/i.test(c.name)) nameScore += 7;
    if (/price/i.test(c.name)) nameScore += 6;
    if (/(revenue|sales|profit|margin)/i.test(c.name)) nameScore += 5;
    if (/(tax|fee|discount|invoice|payment)/i.test(c.name)) nameScore += 4;
    if (/(balance|budget|expense|income|earnings)/i.test(c.name)) nameScore += 4;
    if (/(roi|percentage|rate|ratio)/i.test(c.name)) nameScore += 3;
    if (/(followers|count|quantity|qty)/i.test(c.name)) nameScore += 2;
    
    const vals = rows.slice(0, 2000).map(r => toNum(r[c.name])).filter(Number.isFinite);
    const mean = vals.length ? vals.reduce((a,b)=>a+b,0)/vals.length : 0;
    const varc = vals.length ? vals.reduce((a,b)=>a+(b-mean)*(b-mean),0)/vals.length : 0;
    const finalScore = nameScore + (isFinite(varc) ? Math.log10(1+varc) : 0);
    console.log(`[pickPrimaryMetric] Scoring ${c.name}: nameScore=${nameScore}, varc=${varc.toFixed(2)}, finalScore=${finalScore.toFixed(2)}`);
    return { col: c, score: finalScore };
  });
  scored.sort((a,b)=>b.score-a.score);
  console.log('[pickPrimaryMetric] All scores:', scored.map(s => `${s.col.name}: ${s.score.toFixed(2)}`).join(', '));
  const best = scored[0]?.col || numCols[0] || null;
  console.log('[pickPrimaryMetric] Selected:', best?.name);
  return best;
}

function autoPlan(profile, rows) {
  console.log('[autoPlan] Starting plan...');
  const roles = profile.columns.map(c => ({ col:c, ...inferRole(c, profile, rows) }));
  console.log('[autoPlan] All inferred roles:', roles);
  
  // Enhanced role categorization with business intelligence
  const dims = roles.filter(x => x.role==='dimension').map(x => ({ ...x, col: x.col }));
  const dates = roles.filter(x => x.role==='date').map(x => ({ ...x, col: x.col }));
  const metricsStrong = roles.filter(x => x.role==='metric:strong').map(x => ({ ...x, col: x.col }));
  const metrics = roles.filter(x => x.role==='metric' || x.role==='metric:strong').map(x => ({ ...x, col: x.col }));
  
  // Sort strong metrics by the priority assigned in inferRole
  metricsStrong.sort((a, b) => {
    const priorities = { critical: 3, high: 2, normal: 1, low: 0 };
    const priorityA = priorities[a.priority] || 0;
    const priorityB = priorities[b.priority] || 0;
    return priorityB - priorityA;
  });
  console.log('[autoPlan] Sorted strong metrics:', metricsStrong.map(m => `${m.col.name} (priority: ${m.priority})`));
  
  // Detect hierarchical relationships
  const hierarchicalRels = detectHierarchicalRelationships(profile);
  
  // Categorize dimensions by business context
  const businessDims = {
    financial: dims.filter(d => d.category === 'financial'),
    location: dims.filter(d => d.category === 'location'),
    contact: dims.filter(d => d.category === 'contact'),
    status: dims.filter(d => d.category === 'status'),
    hierarchy: dims.filter(d => d.category === 'hierarchy'),
    temporal: dims.filter(d => d.category === 'temporal'),
    general: dims.filter(d => d.category === 'general' || !d.category)
  };
  
  // Prioritize metrics by business importance
  const financialMetrics = metricsStrong.filter(m => m.category === 'financial');
  const quantityMetrics = metricsStrong.filter(m => m.category === 'quantity');
  const generalMetrics = metricsStrong.filter(m => m.category === 'general' || !m.category);
  
  // Select primary metric with enhanced business logic
  const primary = financialMetrics[0]?.col || quantityMetrics[0]?.col ||
                  metricsStrong[0]?.col || pickPrimaryMetric(profile, rows);
  console.log('[autoPlan] Final primary metric selected:', primary?.name);
  const jobs = []; const charts = [];
  
  // Enhanced temporal analysis with business patterns
  if (dates.length && primary) {
    const dateCol = dates[0];
    const bucket = autoBucket(rows, dateCol.col.name);
    jobs.push({ 
      groupBy: dateCol.col.name, 
      metric: primary.name, 
      agg: dateCol.category === 'financial' ? 'sum' : 'sum',
      dateBucket: bucket,
      temporal: dateCol.temporal
    });
    charts.push({ 
      useJob: jobs.length-1, 
      preferredType: 'line', 
      title: `${primary.name} over ${dateCol.col.name}`,
      priority: 'critical'
    });
  }
  
  // Prioritized dimension analysis based on business context
  const prioritizedDims = [
    ...businessDims.status.slice(0,1),      // Status/Category (highest business value)
    ...businessDims.location.slice(0,1),    // Geographic analysis
    ...businessDims.hierarchy.slice(0,1),   // Organizational structure
    ...businessDims.temporal.slice(0,1),    // Temporal categories
    ...businessDims.general.slice(0,2)      // General dimensions
  ].slice(0,3);
  
  prioritizedDims.forEach(d => {
    if (primary && d.col) {
      // Financial metrics use sum, others use appropriate aggregation
      const aggType = d.category === 'financial' ? 'sum' : 'sum';
      jobs.push({ 
        groupBy: d.col.name, 
        metric: primary.name, 
        agg: aggType,
        category: d.category,
        priority: d.priority
      });
      
      // Smart chart type selection based on data category
      let chartType = 'bar';
      if (d.category === 'status' && d.col.unique <= 8) chartType = 'pie';
      else if (d.category === 'location') chartType = 'bar';
      else if (d.category === 'hierarchy') chartType = 'hbar';
      else if (d.col.unique <= 8) chartType = 'pie';
      
      charts.push({ 
        useJob: jobs.length-1, 
        preferredType: chartType, 
        title: `${primary.name} by ${d.col.name}`,
        category: d.category,
        priority: d.priority === 'high' ? 'high' : 'normal'
      });
      
      // Add average analysis for high-value dimensions
      if (d.priority === 'high' || d.category === 'location') {
        jobs.push({ 
          groupBy: d.col.name, 
          metric: primary.name, 
          agg: 'avg',
          category: d.category,
          priority: d.priority
        });
        charts.push({ 
          useJob: jobs.length-1, 
          preferredType: 'hbar', 
          title: `avg ${primary.name} by ${d.col.name}`,
          category: d.category,
          priority: 'normal'
        });
      }
    }
    
    // Count analysis for all dimensions
    if (d.col) {
      jobs.push({ 
        groupBy: d.col.name, 
        metric: null, 
        agg: 'count',
        category: d.category
      });
      charts.push({ 
        useJob: jobs.length-1, 
        preferredType: d.col.unique <= 8 ? 'pie' : 'bar', 
        title: `count by ${d.col.name}`,
        category: d.category,
        priority: 'low'
      });
    }
  });
  
  // Secondary metric analysis with business context
  const secondaryMetrics = [
    ...quantityMetrics.filter(m => m.col.name !== primary?.name).slice(0,1),
    ...generalMetrics.filter(m => m.col.name !== primary?.name).slice(0,1)
  ];
  
  if (secondaryMetrics.length && prioritizedDims.length) {
    const secondMetric = secondaryMetrics[0];
    const topDim = prioritizedDims[0];
    if (secondMetric.col && topDim.col) {
      jobs.push({ 
        groupBy: topDim.col.name, 
        metric: secondMetric.col.name, 
        agg: secondMetric.category === 'financial' ? 'sum' : 'sum',
        category: secondMetric.category
      });
      charts.push({ 
        useJob: jobs.length-1, 
        preferredType: 'bar', 
        title: `${secondMetric.col.name} by ${topDim.col.name}`,
        category: secondMetric.category,
        priority: 'normal'
      });
    }
  }
  
  return { jobs: jobs.slice(0,10), charts, hierarchicalRels, businessContext: businessDims };
}

function autoBucket(rows, dateCol){
  const ds = rows.map(r=>parseDateSafe(r[dateCol])).filter(x=>!Number.isNaN(x));
  if (!ds.length) return '';
  const spanDays = (Math.max(...ds)-Math.min(...ds))/86400000;
  if (spanDays > 400) return 'month';
  if (spanDays > 120) return 'week';
  return 'day';
}

/* ========= aggregates ========= */
function bucketDate(d, bucket){
  const t = parseDateSafe(d); if (Number.isNaN(t)) return null;
  const dt = new Date(t);
  const y = dt.getUTCFullYear(), m = dt.getUTCMonth()+1, day = dt.getUTCDate();
  if (bucket==='year') return `${y}`;
  if (bucket==='quarter') return `${y}-Q${Math.floor((m-1)/3)+1}`;
  if (bucket==='month') return `${y}-${String(m).padStart(2,'0')}`;
  if (bucket==='week'){
    // Calculate ISO 8601 week number
    // Create a new date for the given date (to avoid modifying the original)
    const date = new Date(Date.UTC(y, dt.getUTCMonth(), day));
    
    // Set to nearest Thursday (current date + 4 - current day number)
    // Make Sunday's day number 7 (convert Sunday from 0 to 7)
    const dayNum = date.getUTCDay() || 7;
    date.setUTCDate(date.getUTCDate() + (4 - dayNum));
    
    // Get first day of year
    const yearStart = new Date(Date.UTC(date.getUTCFullYear(), 0, 1));
    
    // Calculate full weeks to nearest Thursday
    const weekNum = Math.ceil((((date - yearStart) / 86400000) + 1) / 7);
    
    // Return week number in format YYYY-WXX
    return `${date.getUTCFullYear()}-W${String(weekNum).padStart(2,'0')}`;
  }
  return `${y}-${String(m).padStart(2,'0')}-${String(day).padStart(2,'0')}`; // day
}

function groupAgg(rows, groupBy, metric, agg, dateBucket=''){
  const m = new Map();
  const isDateCol = columnType(groupBy)==='date';
  for (const r of rows){
    let g = r[groupBy];
    if (isDateCol && dateBucket){ const b = bucketDate(g, dateBucket); if (b==null) continue; g = b; }
    const key = (g==null || g==='') ? '(blank)' : String(g);
    if (agg==='count'){
      m.set(key, (m.get(key)||0) + 1);
    } else {
      const v = toNum(r[metric]);
      if (isFinite(v)){
        if (!m.has(key)) m.set(key, []);
        m.get(key).push(v);
      }
    }
  }
  const out = [];
  for (const [k, arr] of m){
    let val = 0;
    if (agg==='count') val = arr;
    else if (!arr.length) continue;
    else if (agg==='sum') val = arr.reduce((a,b)=>a+b,0);
    else if (agg==='avg') val = arr.reduce((a,b)=>a+b,0)/arr.length;
    else if (agg==='min') val = Math.min(...arr);
    else if (agg==='max') val = Math.max(...arr);
    else if (agg==='distinct_count') val = new Set(arr).size;
    out.push([k, val]);
  }
  if (isDateCol || dateBucket) {
    // Chronological order for date columns and date buckets
    out.sort((a, b) => {
      const ak = String(a[0] ?? '');
      const bk = String(b[0] ?? '');
      
      // For date buckets, parse the formatted strings back to dates for proper sorting
      if (dateBucket) {
        // Handle different bucket formats
        let dateA, dateB;
        
        if (dateBucket === 'year') {
          // Format: "YYYY"
          dateA = new Date(`${ak}-01-01`);
          dateB = new Date(`${bk}-01-01`);
        } else if (dateBucket === 'quarter') {
          // Format: "YYYY-QX"
          const [, yearA, quarterA] = ak.match(/^(\d+)-Q(\d)$/) || [];
          const [, yearB, quarterB] = bk.match(/^(\d+)-Q(\d)$/) || [];
          if (yearA && quarterA && yearB && quarterB) {
            dateA = new Date(Date.UTC(parseInt(yearA), (parseInt(quarterA) - 1) * 3, 1));
            dateB = new Date(Date.UTC(parseInt(yearB), (parseInt(quarterB) - 1) * 3, 1));
          } else {
            // Fallback to string comparison
            return ak < bk ? -1 : ak > bk ? 1 : 0;
          }
        } else if (dateBucket === 'month') {
          // Format: "YYYY-MM"
          const [, yearA, monthA] = ak.match(/^(\d+)-(\d{2})$/) || [];
          const [, yearB, monthB] = bk.match(/^(\d+)-(\d{2})$/) || [];
          if (yearA && monthA && yearB && monthB) {
            dateA = new Date(Date.UTC(parseInt(yearA), parseInt(monthA) - 1, 1));
            dateB = new Date(Date.UTC(parseInt(yearB), parseInt(monthB) - 1, 1));
          } else {
            // Fallback to string comparison
            return ak < bk ? -1 : ak > bk ? 1 : 0;
          }
        } else if (dateBucket === 'week') {
          // Format: "YYYY-WXX"
          const [, yearA, weekA] = ak.match(/^(\d+)-W(\d{2})$/) || [];
          const [, yearB, weekB] = bk.match(/^(\d+)-W(\d{2})$/) || [];
          if (yearA && weekA && yearB && weekB) {
            // Convert week number to date (Monday of that week)
            dateA = new Date(Date.UTC(parseInt(yearA), 0, 4)); // January 4th (close to first Monday)
            dateA.setDate(dateA.getDate() - ((dateA.getDay() + 6) % 7) + (parseInt(weekA) - 1) * 7);
            
            dateB = new Date(Date.UTC(parseInt(yearB), 0, 4)); // January 4th (close to first Monday)
            dateB.setDate(dateB.getDate() - ((dateB.getDay() + 6) % 7) + (parseInt(weekB) - 1) * 7);
          } else {
            // Fallback to string comparison
            return ak < bk ? -1 : ak > bk ? 1 : 0;
          }
        } else {
          // Day format: "YYYY-MM-DD"
          const partsA = ak.split('-');
          const partsB = bk.split('-');
          if (partsA.length === 3 && partsB.length === 3) {
            dateA = new Date(Date.UTC(parseInt(partsA[0]), parseInt(partsA[1]) - 1, parseInt(partsA[2])));
            dateB = new Date(Date.UTC(parseInt(partsB[0]), parseInt(partsB[1]) - 1, parseInt(partsB[2])));
          } else {
            // Fallback to string comparison
            return ak < bk ? -1 : ak > bk ? 1 : 0;
          }
        }
        
        // Compare the parsed dates
        if (dateA && dateB) {
          return dateA.getTime() - dateB.getTime();
        } else {
          // Fallback to string comparison if parsing failed
          return ak < bk ? -1 : ak > bk ? 1 : 0;
        }
      } else {
        // For regular date columns, parse the values as dates
        const dateA = parseDateSafe(ak);
        const dateB = parseDateSafe(bk);
        
        // If both are valid dates, compare them
        if (!Number.isNaN(dateA) && !Number.isNaN(dateB)) {
          return dateA - dateB;
        } else {
          // Fallback to string comparison
          return ak < bk ? -1 : ak > bk ? 1 : 0;
        }
      }
    });
  } else {
    // Default: sort by metric descending for non-date columns
    out.sort((a,b)=> (Number(b[1]||0) - Number(a[1]||0)));
  }
  return { header:[isDateCol && dateBucket ? `${groupBy} (${dateBucket})` : groupBy, `${agg}(${metric||'*'})`], rows: out };
}

/* ========= charting (FIXED HEIGHT + SAFE REDRAW + MORE TYPES) ========= */
const chartRegistry = new WeakMap(); // canvas -> { chart, ro }
function computeChartConfig(agg, typePref, topN){
  const total = agg.rows.length;

  // Determine type first
  let type='bar', indexAxis='x', fill=false;
  if (typePref==='hbar'){ type='bar'; indexAxis='y'; }
  else if (typePref==='line'){ type='line'; }
  else if (typePref==='area'){ type='line'; fill=true; }
  else if (['pie','doughnut','polarArea','radar'].includes(typePref)){ type=typePref; }
  else if (typePref==='auto'){ type = (total<=8 ? 'pie' : 'bar'); }

  const isCircular = (type==='pie' || type==='doughnut' || type==='polarArea' || type==='radar');

  // Limit categories when Top-N provided (applies to circular and bar charts); line/area keep full series
let rows=[...agg.rows];
const limit = Number(topN);
if (Number.isFinite(limit) && limit>0 && rows.length>limit && (isCircular || type==='bar')){
  const head = rows.slice(0, limit);
  const other = rows.slice(limit).reduce((a,b)=> a + (+b[1] || 0), 0);
  rows = other ? [...head, ['Other', other]] : head;
}

  const labels=rows.map(r=>String(r[0]));
  const values=rows.map(r=>Number(r[1])||0);

  return {
    type,
    data:{
      labels,
      datasets:[{
        label: agg.header[1],
        data: values,
        fill,
        tension: 0.4,
        borderColor: '#2563eb',
        backgroundColor: (type === 'pie' || type === 'doughnut')
          ? [
            '#2563eb', '#3b82f6', '#60a5fa', '#93c5fd', '#bfdbfe',
            '#10b981', '#34d399', '#6ee7b7', '#a7f3d0', '#d1fae5',
            '#8b5cf6', '#a78bfa', '#c4b5fd', '#ddd6fe', '#ede9fe',
            '#f59e0b', '#fbbf24', '#fcd34d', '#fde68a', '#fef3c7'
          ]
          : 'rgba(37, 99, 235, 0.1)',
        pointBackgroundColor: '#2563eb',
        pointRadius: 4,
        borderWidth: 2,
        borderRadius: type === 'bar' ? 4 : 0,
        borderSkipped: false
      }]
    },
    options:{
      responsive:true,
      maintainAspectRatio:false,
      animation:{
        duration: 1000,
        easing: 'easeOutQuart'
      },
      // Pin pixel ratio to avoid apparent CSS growth when DPR changes
      devicePixelRatio: 1,
      indexAxis,
      plugins:{
        legend:{
          display: isCircular || labels.length<=20,
          labels: {
            font: {
              size: 12,
              family: 'system-ui, Segoe UI, Arial, sans-serif'
            },
            padding: 20,
            usePointStyle: true,
            pointStyle: 'circle'
          }
        },
        tooltip:{
          backgroundColor: 'rgba(255, 255, 255, 0.95)',
          titleColor: '#0b1220',
          bodyColor: '#0b1220',
          borderColor: '#e2e8f0',
          borderWidth: 1,
          cornerRadius: 8,
          displayColors: true,
          callbacks:{
            label: ctx => {
              const v = ctx.parsed?.y ?? ctx.parsed ?? ctx.raw;
              return `${ctx.dataset.label}: ${nice(v)}`;
            }
          }
        },
        // Enable point decimation for line/area to keep performance with many points
        decimation:{ enabled: (type==='line'), algorithm:'lttb' }
      },
      scales: isCircular ? {} : {
        x: {
          beginAtZero: true,
          grid: {
            color: 'rgba(226, 232, 240, 0.3)',
            drawBorder: true
          },
          ticks: {
            autoSkip: true,
            maxRotation: 0,
            font: {
              size: 11,
              family: 'system-ui, Segoe UI, Arial, sans-serif'
            },
            callback: (indexAxis === 'x') ? undefined : function(value) {
              // Format numeric values on x-axis (for horizontal bar charts)
              return nice(value);
            }
          }
        },
        y: {
          beginAtZero: true,
          grid: {
            color: 'rgba(226, 232, 240, 0.3)',
            drawBorder: true
          },
          ticks: {
            autoSkip: true,
            maxRotation: 0,
            font: {
              size: 11,
              family: 'system-ui, Segoe UI, Arial, sans-serif'
            },
            callback: (indexAxis === 'y') ? undefined : function(value) {
              // Format numeric values on y-axis (for vertical bar charts)
              return nice(value);
            }
          }
        }
      }
    }
  };
}
function ensureChart(canvas, cfg, shouldResize=false){
  const rec = chartRegistry.get(canvas);
  let chart = rec ? rec.chart : null;
  let ro = rec ? rec.ro : null;

  // Check if chart type has changed or if chart doesn't exist
  if (!chart || chart.config.type !== cfg.type) {
    if (chart) {
      try { chart.destroy(); } catch {}
      if (ro) { try { ro.disconnect(); } catch {} }
      chartRegistry.delete(canvas);
    }
    // Create new chart
    chart = new Chart(canvas.getContext('2d'), cfg);
    ro = new ResizeObserver(()=>{ if (chart) chart.resize(); });
    const parent = canvas.parentElement; if (parent) ro.observe(parent);
    chartRegistry.set(canvas, { chart, ro });
  } else {
    // Update existing chart
    chart.data.labels = cfg.data.labels;
    chart.data.datasets[0].data = cfg.data.datasets[0].data;
    
    // Update dataset properties that might change (like fill for line/area switch)
    Object.assign(chart.data.datasets[0], cfg.data.datasets[0]);
    
    // Merge options to allow for dynamic updates without full recreation
    Object.assign(chart.options, cfg.options);
    
    // Only force a resize when CSS dimension actually changed
    if (shouldResize) chart.resize();
    chart.update('none'); // snappier redraw without animation
  }
  return chart;
}
function renderChartCard(agg, chartsContainer, defaultType='auto', defaultTopN=20, titleForFile='chart'){
  const c = document.createElement('div'); c.className='chart-card';
  const head = document.createElement('div'); head.className='chart-head';
  const left = document.createElement('div'); left.className='small muted'; left.textContent = `Chart for: ${agg.header[1]} by ${agg.header[0]}`;
  
  // Create chart controls container
  const controls = document.createElement('div'); controls.className='chart-controls';
  
  const typeSel = document.createElement('select');
  typeSel.innerHTML = `
    <option value="auto">Auto</option>
    <option value="bar">Bar (vertical)</option>
    <option value="hbar">Bar (horizontal)</option>
    <option value="line">Line</option>
    <option value="area">Area</option>
    <option value="pie">Pie</option>
    <option value="doughnut">Doughnut</option>
    <option value="polarArea">Polar Area</option>
    <option value="radar">Radar</option>`;
  typeSel.value = defaultType;
  
  const topNInput = document.createElement('input');
  topNInput.type='number';
  topNInput.min='3';
  topNInput.max='999';
  topNInput.value=String(defaultTopN);
  topNInput.placeholder='Top-N';
  
  const editBtn = document.createElement('button'); 
  editBtn.textContent='Edit';
  editBtn.className='btn-secondary';
  editBtn.title='Edit chart configuration';
  
  const redrawBtn = document.createElement('button'); redrawBtn.textContent='Redraw';
  const pngBtn = document.createElement('button'); pngBtn.textContent='Download PNG';
  const addChartBtn = document.createElement('button'); addChartBtn.textContent = 'Add Chart';
  const deleteBtn = document.createElement('button'); deleteBtn.textContent = 'Delete';

  controls.append(typeSel, topNInput, editBtn, redrawBtn, pngBtn, addChartBtn, deleteBtn);
  head.append(left, controls);
  // Auto redraw + auto-save on control changes
  typeSel.addEventListener('change', () => { draw(); debouncedAutoSave(); });
  topNInput.addEventListener('change', () => { draw(); debouncedAutoSave(); });

  addChartBtn.onclick = () => {
    const t = typeSel.value;
    const n = Math.max(3, Math.min(999, Number(topNInput.value) || 20));
    const parentCard = c.closest('.card');
    const chartsContainer = parentCard.querySelector('.chart-cards');
    const title = parentCard.querySelector('.card-title').textContent;
    renderChartCard(agg, chartsContainer, t, n, title.replace(/\s+/, '_'));
    showToast('New chart card added.', 'success');
    debouncedAutoSave();
  };

  deleteBtn.onclick = () => {
    const chartCard = c;
    const rec = chartRegistry.get(canvas);
    if (rec) {
      if (rec.ro) {
        try { rec.ro.disconnect(); } catch {}
      }
      if (rec.chart) {
        try { rec.chart.destroy(); } catch {}
      }
      chartRegistry.delete(canvas);
    }
    chartCard.remove();
    showToast('Chart deleted.', 'info');
    debouncedAutoSave();
  };
  c.appendChild(head);
  const box = document.createElement('div'); box.className='chart-box';
  const canvas = document.createElement('canvas'); box.appendChild(canvas); c.appendChild(box); chartsContainer.appendChild(c);
  function draw(){
    const topN = Number(topNInput.value)||20;
    const cfg = computeChartConfig(agg, typeSel.value, topN);
    const isCircular = (cfg.type==='pie' || cfg.type==='doughnut' || cfg.type==='polarArea' || cfg.type==='radar');

    // Keep previously applied dims to detect changes
    const prevW = canvas.dataset.w || '';
    const prevH = canvas.dataset.h || '';

    // Completely reset all inline styles to avoid conflicts
    canvas.setAttribute('style', '');
    
    // Force container-based sizing first
    canvas.style.display = 'block';
    canvas.style.width = '100%';
    canvas.style.height = '100%';

    // Determine target size
    let shouldResize = false;

    // Let all charts use container sizing for responsive design
    shouldResize = (prevW || prevH); // trigger resize if we had custom sizing before
    
    // Clear any previous custom sizing
    delete canvas.dataset.w;
    delete canvas.dataset.h;

    ensureChart(canvas, cfg, shouldResize);
    showToast('Chart redrawn.', 'info');
  }
  
  // Create edit panel (initially hidden)
  const editPanel = document.createElement('div');
  editPanel.className = 'edit-panel';
  editPanel.style.display = 'none';
  editPanel.style.padding = '12px';
  editPanel.style.background = '#f8f9fa';
  editPanel.style.border = '1px solid #e2e8f0';
  editPanel.style.borderRadius = '8px';
  editPanel.style.marginTop = '8px';
  
  // Extract current configuration
  const groupByCol = agg.header[0];
  const metricCol = agg.header[1] !== 'count' ? agg.header[1] : null;
  const aggFunction = agg.header[1] === 'count' ? 'count' : 
                     agg.header[1].includes('avg') ? 'avg' : 
                     agg.header[1].includes('sum') ? 'sum' : 'sum';
  
  // Detect date bucket from groupBy column
  let dateBucket = '';
  const bucketMatch = groupByCol.match(/\((day|week|month|quarter|year)\)/i);
  if (bucketMatch) {
    dateBucket = bucketMatch[1].toLowerCase();
  }
  const cleanGroupBy = groupByCol.replace(/\s*\((day|week|month|quarter|year)\)$/i, '');
  
  // Create edit controls
  editPanel.innerHTML = `
    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 12px; align-items: end;">
      <label>Group by:
        <select id="edit-groupby" style="width: 100%; margin-top: 4px;">
          ${PROFILE.columns.filter(c => ['string','date'].includes(c.type)).map(c => 
            `<option value="${c.name}" ${c.name === cleanGroupBy ? 'selected' : ''}>${c.name}</option>`
          ).join('')}
        </select>
      </label>
      <label>Date bucket:
        <select id="edit-bucket" style="width: 100%; margin-top: 4px;">
          <option value="">None</option>
          <option value="day" ${dateBucket === 'day' ? 'selected' : ''}>Day</option>
          <option value="week" ${dateBucket === 'week' ? 'selected' : ''}>Week</option>
          <option value="month" ${dateBucket === 'month' ? 'selected' : ''}>Month</option>
          <option value="quarter" ${dateBucket === 'quarter' ? 'selected' : ''}>Quarter</option>
          <option value="year" ${dateBucket === 'year' ? 'selected' : ''}>Year</option>
        </select>
      </label>
      <label>Metric:
        <select id="edit-metric" style="width: 100%; margin-top: 4px;">
          <option value="">Count records</option>
          ${PROFILE.columns.filter(c => c.type === 'number').map(c => 
            `<option value="${c.name}" ${c.name === metricCol ? 'selected' : ''}>${c.name}</option>`
          ).join('')}
        </select>
      </label>
      <label>Function:
        <select id="edit-function" style="width: 100%; margin-top: 4px;">
          <option value="sum" ${aggFunction === 'sum' ? 'selected' : ''}>Sum</option>
          <option value="avg" ${aggFunction === 'avg' ? 'selected' : ''}>Average</option>
          <option value="count" ${aggFunction === 'count' ? 'selected' : ''}>Count</option>
        </select>
      </label>
      <div style="display: flex; gap: 8px;">
        <button id="edit-apply" style="padding: 6px 12px; background: #2563eb; color: white; border: none; border-radius: 4px; cursor: pointer;">Apply</button>
        <button id="edit-cancel" style="padding: 6px 12px; background: #6b7280; color: white; border: none; border-radius: 4px; cursor: pointer;">Cancel</button>
      </div>
    </div>
  `;
  
  c.appendChild(editPanel);
  
  // Add dynamic behavior to metric/function relationship
  const metricSelect = editPanel.querySelector('#edit-metric');
  const functionSelect = editPanel.querySelector('#edit-function');
  
  metricSelect.addEventListener('change', () => {
    if (!metricSelect.value) {
      // No metric selected - force count function
      functionSelect.value = 'count';
      functionSelect.disabled = true;
    } else {
      // Metric selected - enable all functions
      functionSelect.disabled = false;
      if (functionSelect.value === 'count') {
        functionSelect.value = 'sum'; // Default to sum when metric is selected
      }
    }
  });
  
  // Initialize function dropdown state
  if (!metricSelect.value) {
    functionSelect.value = 'count';
    functionSelect.disabled = true;
  }
  
  // Edit button functionality
  editBtn.onclick = () => {
    if (editPanel.style.display === 'none') {
      editPanel.style.display = 'block';
      editBtn.textContent = 'Cancel Edit';
    } else {
      editPanel.style.display = 'none';
      editBtn.textContent = 'Edit';
    }
  };
  
  // Apply changes functionality
  editPanel.querySelector('#edit-apply').onclick = () => {
    const newGroupBy = editPanel.querySelector('#edit-groupby').value;
    const newBucket = editPanel.querySelector('#edit-bucket').value;
    const newMetric = editPanel.querySelector('#edit-metric').value || null;
    const newFunction = editPanel.querySelector('#edit-function').value;

    // If no metric selected, force count
    const finalFunction = !newMetric ? 'count' : newFunction;

    // Recompute aggregate for this card
    const newAgg = groupAgg(ROWS, newGroupBy, newMetric, finalFunction, newBucket);

    // Update the current card's aggregate data (affects all charts in this card)
    agg.header = newAgg.header;
    agg.rows = newAgg.rows;

    // Update the header display for this chart card
    left.textContent = `Chart for: ${newAgg.header[1]} by ${newAgg.header[0]}`;

    // Find and update the associated table and persist job definition on the parent card
    const chartCard = c;
    const chartsContainer = chartCard.parentElement;
    const parentCard = chartsContainer.parentElement;

    if (parentCard) {
      // Persist job definition so snapshots capture this edit
      parentCard.dataset.groupBy = newGroupBy || '';
      parentCard.dataset.metric = newMetric || '';
      parentCard.dataset.agg = finalFunction || '';
      parentCard.dataset.dateBucket = newBucket || '';

      // Update card subheader
      const cardSub = parentCard.querySelector('.card-sub');
      if (cardSub) {
        cardSub.textContent = `${newAgg.rows.length} groups · ${newAgg.header[1]}`;
      }

      // Re-render table
      const tableBox = parentCard.querySelector('.table-wrap');
      if (tableBox) {
        renderAggTable(agg, tableBox, 20);
      }
    }

    // Redraw the chart with new data
    draw();

    // Hide edit panel
    editPanel.style.display = 'none';
    editBtn.textContent = 'Edit';
    showToast('Aggregate updated for this card and will be saved in history.', 'success');
    debouncedAutoSave();
  };
  
  // Cancel edit functionality
  editPanel.querySelector('#edit-cancel').onclick = () => {
    editPanel.style.display = 'none';
    editBtn.textContent = 'Edit';
    showToast('Aggregate table updated.', 'success');
  };
  
  redrawBtn.onclick = () => { draw(); debouncedAutoSave(); }; pngBtn.onclick = ()=>{ const a=document.createElement('a'); a.href=canvas.toDataURL('image/png'); a.download = `${titleForFile}.png`; a.click(); showToast('Chart downloaded as PNG.', 'success'); };
  draw();
  return c;
}

/* ========= aggregate table (sortable + download) ========= */
function renderAggTable(agg, container, previewN=10){
  container.innerHTML = '';
  
  // State variables for this table
  let currentPage = 1;
  let rowsPerPage = previewN;
  let searchQuery = '';
  let sortIdx = /\((day|week|month|quarter|year)\)/i.test(agg.header[0]||'') ? 0 : 1;
  let sortDir = sortIdx===0 ? 'asc' : 'desc';
  let filteredRows = [...agg.rows];
  
  // Create table elements
  const tableControls = document.createElement('div');
  tableControls.className = 'table-controls';
  
  const tableWrap = document.createElement('div');
  tableWrap.className = 'data-table-wrap';
  
  const table = document.createElement('table');
  const thead = document.createElement('thead');
  const tbody = document.createElement('tbody');
  const tfoot = document.createElement('tfoot');
  
  // Create search input
  const searchLabel = document.createElement('label');
  searchLabel.textContent = 'Search: ';
  const searchInput = document.createElement('input');
  searchInput.type = 'text';
  searchInput.placeholder = 'Type to filter...';
  searchInput.style.minWidth = '150px';
  searchLabel.appendChild(searchInput);
  
  // Create rows per page selector
  const rowsPerPageLabel = document.createElement('label');
  rowsPerPageLabel.textContent = 'Rows per page: ';
  const rowsPerPageSelect = document.createElement('select');
  rowsPerPageSelect.innerHTML = `
    <option value="10">10</option>
    <option value="25">25</option>
    <option value="50">50</option>
    <option value="100">100</option>
    <option value="0">All</option>
  `;
  rowsPerPageSelect.value = String(previewN);
  rowsPerPageLabel.appendChild(rowsPerPageSelect);
  
  // Create pager
  const pager = document.createElement('div');
  pager.className = 'pager';
  const prevButton = document.createElement('button');
  prevButton.textContent = 'Prev';
  const pageInfo = document.createElement('span');
  pageInfo.className = 'count';
  pageInfo.textContent = 'Page 1 / 1';
  const nextButton = document.createElement('button');
  nextButton.textContent = 'Next';
  pager.append(prevButton, pageInfo, nextButton);
  
  tableControls.append(searchLabel, rowsPerPageLabel, pager);
  container.appendChild(tableControls);
  
  // Create table header
  const trh = document.createElement('tr');
  const headerSortSpans = [];
  agg.header.forEach((h, i) => {
    const th = document.createElement('th');
    th.textContent = h;
    const s = document.createElement('span');
    s.className = 'sort';
    s.textContent = '';
    th.appendChild(s);
    headerSortSpans[i] = s;
    th.style.cursor = 'pointer';
    th.addEventListener('click', () => {
      if (sortIdx === i) {
        sortDir = (sortDir === 'asc' ? 'desc' : 'asc');
      } else {
        sortIdx = i;
        sortDir = i === 0 ? 'asc' : 'desc';
      }
      currentPage = 1;
      updateTable();
    });
    trh.appendChild(th);
  });
  thead.appendChild(trh);
  table.appendChild(thead);
  table.appendChild(tbody);
  table.appendChild(tfoot);
  tableWrap.appendChild(table);
  container.appendChild(tableWrap);
  
  // Create footer with download button
  const foot = document.createElement('div');
  foot.className = 'card-foot';
  const dl = document.createElement('button');
  dl.textContent = 'Download CSV';
  dl.onclick = () => {
    const csv = [agg.header, ...agg.rows].map(r => r.map(s => {
      const z = String(s ?? '');
      return /[",\n]/.test(z) ? `"${z.replace(/"/g, '""')}"` : z;
    }).join(',')).join('\n');
    const blob = new Blob([csv], { type: 'text/csv;charset=utf-8' });
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = `${(agg.header[1] + ' by ' + agg.header[0]).replace(/\s+/g, '_')}.csv`;
    a.click();
    URL.revokeObjectURL(a.href);
    showToast('Aggregate data downloaded as CSV.', 'success');
  };
  foot.appendChild(dl);
  container.appendChild(foot);
  
  // Function to highlight search terms in text
  function highlightText(text, query) {
    if (!query || !query.trim()) return text;
    // Escape HTML in the text first to prevent XSS
    const safeText = String(text).replace(/[&<>"']/g, function(m) {
      return {'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m];
    });
    const escapedQuery = query.trim().replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
    const regex = new RegExp(`(${escapedQuery})`, 'gi');
    return safeText.replace(regex, '<mark>$1</mark>');
  }
  
  // Filter rows based on search query
  function filterRows() {
    const query = searchQuery.toLowerCase().trim();
    if (!query) {
      filteredRows = [...agg.rows];
      return;
    }
    
    filteredRows = agg.rows.filter(row => {
      return row.some(cell => String(cell).toLowerCase().includes(query));
    });
  }
  
  // Sort rows
  function sortRows() {
    filteredRows.sort((a, b) => {
      if (sortIdx === 1) {
        const av = Number(a[1]) || 0;
        const bv = Number(b[1]) || 0;
        return sortDir === 'asc' ? (av - bv) : (bv - av);
      } else {
        const as = String(a[0] ?? '').toLowerCase();
        const bs = String(b[0] ?? '').toLowerCase();
        const cmp = as < bs ? -1 : as > bs ? 1 : 0;
        return sortDir === 'asc' ? cmp : -cmp;
      }
    });
  }
  
  // Render table body
  function renderTableBody() {
    tbody.innerHTML = '';
    
    const totalFiltered = filteredRows.length;
    const totalPages = rowsPerPage === 0 ? 1 : Math.ceil(totalFiltered / rowsPerPage);
    
    // Adjust current page if it's out of bounds
    if (currentPage > totalPages && totalPages > 0) {
      currentPage = totalPages;
    }
    
    // Calculate start and end indices
    let start, end;
    if (rowsPerPage === 0) {
      // Show all rows
      start = 0;
      end = totalFiltered;
    } else {
      // Show paginated rows
      start = (currentPage - 1) * rowsPerPage;
      end = Math.min(start + rowsPerPage, totalFiltered);
    }
    
    // Get rows to display
    const displayRows = filteredRows.slice(start, end);
    
    // Render rows with highlighted search terms
    displayRows.forEach(r => {
      const tr = document.createElement('tr');
      const td0 = document.createElement('td');
      td0.innerHTML = highlightText(String(r[0]), searchQuery);
      const td1 = document.createElement('td');
      const numValue = nice(Number(r[1]) || 0);
      // Apply highlighting to numeric values too
      if (searchQuery.trim()) {
        td1.innerHTML = highlightText(String(numValue), searchQuery);
      } else {
        td1.textContent = numValue;
      }
      tr.append(td0, td1);
      tbody.appendChild(tr);
    });
    
    // Update page info
    if (totalFiltered === 0) {
      pageInfo.textContent = 'No rows found';
    } else if (rowsPerPage === 0) {
      pageInfo.textContent = `Showing all ${totalFiltered} rows`;
    } else {
      pageInfo.textContent = `Page ${currentPage} / ${totalPages} (${totalFiltered} total)`;
    }
    
    // Update button states
    prevButton.disabled = currentPage <= 1;
    nextButton.disabled = currentPage >= totalPages;
  }
  
  // Render table footer with sums
  function renderTableFooter() {
    tfoot.innerHTML = '';
    const tr = document.createElement('tr');
    
    // Calculate sums only for numeric columns
    agg.header.forEach((h, i) => {
      const td = document.createElement('td');
      if (i === 1) { // Assuming second column is numeric
        let sum = 0;
        for (const r of filteredRows) {
          const val = Number(r[i]) || 0;
          if (!isNaN(val)) sum += val;
        }
        td.textContent = 'Σ ' + nice(sum);
      } else {
        td.textContent = '';
      }
      tr.appendChild(td);
    });
    
    tfoot.appendChild(tr);
  }
  
  // Update entire table
  function updateTable() {
    filterRows();
    sortRows();
    renderTableBody();
    renderTableFooter();
  }
  
  // Event listeners
  searchInput.addEventListener('input', debounce(() => {
    searchQuery = searchInput.value;
    currentPage = 1;
    updateTable();
  }, 300));
  
  rowsPerPageSelect.addEventListener('change', () => {
    const val = rowsPerPageSelect.value;
    rowsPerPage = val === '0' ? 0 : Number(val);
    currentPage = 1;
    updateTable();
  });
  
  prevButton.addEventListener('click', () => {
    if (currentPage > 1) {
      currentPage--;
      updateTable();
    }
  });
  
  nextButton.addEventListener('click', () => {
    const totalPages = rowsPerPage === 0 ? 1 : Math.ceil(filteredRows.length / rowsPerPage);
    if (currentPage < totalPages) {
      currentPage++;
      updateTable();
    }
  });
  
  // Initial render
  updateTable();
}

/* ========= Manual Mode: Role Editor + Add Aggregate ========= */
function openRoleEditor(){
  const modal = $('#roleModal'); const tb = $('#roleTBody'); tb.innerHTML='';
  PROFILE.columns.forEach(c=>{
    const tr=document.createElement('tr');
    const roleAuto = inferRole(c, PROFILE, ROWS).role;
    const current = MANUAL_ROLES[c.name] || roleAuto;
    const tdName = document.createElement('td'); tdName.textContent = c.name;
    const tdType = document.createElement('td'); tdType.textContent = c.type;
    const tdUniq = document.createElement('td'); tdUniq.textContent = c.unique;
    const tdRole = document.createElement('td');
    const sel = document.createElement('select'); sel.setAttribute('data-col', c.name);
    ['dimension','metric','date','id','ignore'].forEach(v=>{ const o=document.createElement('option'); o.value=v; o.textContent=v; sel.appendChild(o); });
    sel.value = current.replace('metric:strong','metric'); tdRole.appendChild(sel);
    const tdSample = document.createElement('td'); tdSample.className='muted small'; tdSample.textContent = (c.samples||[]).join(' | ');
    tr.append(tdName, tdType, tdUniq, tdRole, tdSample); tb.appendChild(tr);
  });
  modal.classList.add('open');
  modal.focus();
}
$('#closeRoleModal').onclick = ()=> $('#roleModal').classList.remove('open');
$('#saveRoles').onclick = ()=>{
  MANUAL_ROLES = {};
  $('#roleTBody').querySelectorAll('select').forEach(sel=>{ MANUAL_ROLES[ sel.getAttribute('data-col') ] = sel.value; });
  $('#roleModal').classList.remove('open');
  renderAggregates();
  showToast('Column roles saved.', 'success');
  debouncedAutoSave();
};

function planFromManualRoles(profile){
  const getCols = (role)=> profile.columns.filter(c => (MANUAL_ROLES[c.name]||'')===role);
  const dims = getCols('dimension');
  const dates = getCols('date');
  const metrics = getCols('metric');
  const primary = metrics[0] || pickPrimaryMetric(profile, ROWS);
  const jobs=[], charts=[];
  if (dates.length && primary){
    jobs.push({ groupBy: dates[0].name, metric: primary.name, agg:'sum', dateBucket:autoBucket(ROWS, dates[0].name) });
    charts.push({ useJob: jobs.length-1, preferredType:'line', title:`${primary.name} over ${dates[0].name}` });
  }
  dims.slice(0,3).forEach(d=>{
    if (primary){
      jobs.push({ groupBy:d.name, metric:primary.name, agg:'sum' });
      charts.push({ useJob: jobs.length-1, preferredType:d.unique<=8?'pie':'bar', title:`${primary.name} by ${d.name}` });
      jobs.push({ groupBy:d.name, metric:primary.name, agg:'avg' });
      charts.push({ useJob: jobs.length-1, preferredType:'hbar', title:`avg ${primary.name} by ${d.name}` });
    }
    jobs.push({ groupBy:d.name, metric:null, agg:'count' });
    charts.push({ useJob: jobs.length-1, preferredType:d.unique<=8?'pie':'bar', title:`count by ${d.name}` });
  });
  return { jobs: jobs.slice(0,10), charts };
}

function openAddAgg(){
  const modal = $('#aggModal');
  const gb = $('#aggGroupBy'), mt = $('#aggMetric');
  const bucket = $('#aggBucket'); gb.innerHTML=''; mt.innerHTML=''; bucket.value='';
  const dims = MODE==='manual'
    ? PROFILE.columns.filter(c => (MANUAL_ROLES[c.name]||'')==='dimension' || (MANUAL_ROLES[c.name]||'')==='date')
    : PROFILE.columns.filter(c => ['string','date'].includes(c.type));
  const nums = MODE==='manual'
    ? PROFILE.columns.filter(c => (MANUAL_ROLES[c.name]||'')==='metric')
    : PROFILE.columns.filter(c => c.type==='number');
  dims.forEach(c=>{ const o=document.createElement('option'); o.value=c.name; o.textContent=c.name; gb.appendChild(o); });
  nums.forEach(c=>{ const o=document.createElement('option'); o.value=c.name; o.textContent=c.name; mt.appendChild(o); });
  modal.classList.add('open');
}
$('#closeAggModal').onclick = ()=> $('#aggModal').classList.remove('open');
$('#addAggConfirm').onclick = ()=>{
  const groupBy = $('#aggGroupBy').value;
  const metric  = $('#aggMetric').value || null;
  const agg     = $('#aggFunc').value;
  const chart   = $('#aggChart').value;
  const topN    = Math.max(3, Math.min(999, Number($('#aggTopN').value)||20));
  const dateBucket = $('#aggBucket').value || '';
  MANUAL_JOBS.push({ groupBy, metric, agg, chart, topN, dateBucket });
  $('#aggModal').classList.remove('open');
  renderAggregates();
  showToast('New aggregate added.', 'success');
  debouncedAutoSave();
};

/* ========= UI glue ========= */
$('#loadBtn').onclick = async ()=>{
  const f=$('#file').files[0]; if(!f) return showToast('Choose a CSV first.', 'error');
  $('#meta').textContent='Parsing…';
  try{
    const choice=$('#delimiter').value, header=$('#hasHeader').checked;
    const {data, meta}=await parseCSV(f, choice, header);
    if(!data.length) throw new Error('No rows detected (check delimiter/header).');
    ROWS=data; DATA_COLUMNS = Object.keys(ROWS[0] || {});
    PROFILE=profile(ROWS); renderProfile(PROFILE);
    $('#meta').textContent=`Loaded ${PROFILE.rowCount.toLocaleString()} rows, ${PROFILE.columns.length} columns. (delimiter="${meta.delimiter}")`;
    $('#results').innerHTML='';
    buildRawHeader(DATA_COLUMNS);
    QUERY = ''; $('#searchInput').value='';
    SORT = { col:null, dir:'asc' };
    RPP = Number($('#rowsPerPage').value)||25; PAGE=1;
    applyFilter(); renderRawBody();
    MANUAL_ROLES = {}; MANUAL_JOBS = [];
    $('#mode').value='auto'; switchMode('auto');
    loadState(); // restore per-header state if available
    showToast('CSV data loaded successfully.', 'success');

    // Auto-save the initial load as a new history item
    await saveCurrentStateToHistory(f.name, true); // Pass true to force new entry

    // Enable the update and save as new buttons
    $('#updateReportBtn').disabled = false;
    $('#saveAsNewBtn').disabled = false;

  }catch(e){ console.error(e); showToast('Parse error: '+(e?.message||e), 'error'); $('#meta').textContent='Parse failed.'; }
};

function switchMode(val){
  MODE = val;
  const manual = MODE==='manual';
  $('#editRolesBtn').style.display = manual ? '' : 'none';
  $('#addAggBtn').style.display   = manual ? '' : 'none';
  $('#clearManualBtn').style.display = manual ? '' : 'none';
  $('#recalcBtn').style.display = manual ? '' : 'none';
}
$('#mode').addEventListener('change', e=>{ switchMode(e.target.value); renderAggregates(); });
$('#editRolesBtn').onclick = openRoleEditor;
$('#addAggBtn').onclick = openAddAgg;
$('#clearManualBtn').onclick = ()=>{ MANUAL_ROLES={}; MANUAL_JOBS=[]; renderAggregates(); showToast('Manual overrides cleared.', 'info'); debouncedAutoSave(); };
$('#recalcBtn').onclick = ()=>{ renderAggregates(); showToast('Recalculated with current roles', 'success'); debouncedAutoSave(); };

$('#searchInput').addEventListener('input', onSearch);
$('#rowsPerPage').addEventListener('change', ()=>{ RPP = Number($('#rowsPerPage').value)||25; PAGE=1; renderRawBody(); });
$('#prevPage').addEventListener('click', ()=>{ if(PAGE>1){ PAGE--; renderRawBody(); } });
$('#nextPage').addEventListener('click', ()=>{ const pages=Math.max(1, Math.ceil(FILTERED_ROWS.length / RPP)); if(PAGE<pages){ PAGE++; renderRawBody(); } });
$('#downloadFiltered').addEventListener('click', ()=>{
  if (!FILTERED_ROWS?.length) return;
  const esc = s => { const str = String(s ?? ''); return /[",\n]/.test(str) ? `"${str.replace(/"/g,'""')}"` : str; };
  const header = DATA_COLUMNS.map(esc).join(',');
  const sorted = sortRows(FILTERED_ROWS);
  const body = sorted.map(r => DATA_COLUMNS.map(c => esc(r[c])).join(',')).join('\n');
  const blob = new Blob([header+'\n'+body], {type:'text/csv;charset=utf-8'});
  const a = document.createElement('a'); a.href = URL.createObjectURL(blob);
  a.download = 'filtered_rows.csv'; a.click(); URL.revokeObjectURL(a.href);
  showToast('Filtered CSV downloaded', 'success');
});

$('#autoBtn').onclick = () => renderAggregates();

function renderAggregates(chartsSnapshot = null){
  if(!ROWS) return showToast('Load a CSV first.', 'error');
  
  // Snapshot restoration handled later using saved jobKey; fall through to unified path

  // Original logic for generating new aggregates
  let plan;
    if (MODE === 'manual') {
    if (MANUAL_JOBS.length) { plan = { jobs: MANUAL_JOBS.slice(0, 10), charts: [] }; }
    else if (Object.keys(MANUAL_ROLES).length) { plan = planFromManualRoles(PROFILE); }
    else { plan = autoPlan(PROFILE, ROWS); }
  } else {
    plan = autoPlan(PROFILE, ROWS);
  }
  window.CURRENT_PLAN = plan; // Store plan for snapshotting

  const grid=$('#results'); grid.innerHTML='';

  // If a snapshot is provided, rebuild each card directly from its saved jobKey
  if (chartsSnapshot && chartsSnapshot.length > 0) {
    chartsSnapshot.forEach(cardSnap => {
      let jobKey = (cardSnap?.charts?.[0]?.jobKey) || cardSnap?.cardJobKey || null;

      // Back-compat: allow deriving from legacy chart fields or title if jobKey is missing/incomplete
      if (!jobKey || !jobKey.groupBy || !jobKey.agg) {
        // 1) Legacy snapshots: some versions stored groupBy/metric on each chart
        const legacy = (cardSnap?.charts || []).find(ch => ch && (ch.groupBy || ch.metric));
        if (legacy && legacy.groupBy && (!jobKey || !jobKey.groupBy)) {
          let derivedAgg = 'sum';
          let metric = (legacy.metric !== undefined ? legacy.metric : null);
          if (metric === '' || metric === undefined) metric = null;
          if (!metric) derivedAgg = 'count';
          // Try to refine agg from title if available, e.g., "avg Sales by Region"
          const t = cardSnap?.title || '';
          const am = t.match(/^(count|sum|avg|min|max|distinct_count)\s*\(/i);
          if (am) derivedAgg = am[1].toLowerCase();
          jobKey = { groupBy: legacy.groupBy, metric, agg: derivedAgg, dateBucket: '' };
        }
      }

      if (!jobKey || !jobKey.groupBy || !jobKey.agg) {
        // 2) Title parsing fallback: e.g., "sum(Sales) by Country" or "count by Product"
        const title = cardSnap?.title || '';
        const m = title.match(/^(.*?)\s+by\s+(.*)$/i);
        if (m) {
          let lhs = (m[1] || '').trim();
          let rhs = (m[2] || '').trim();
          let dateBucket = '';
          const bucketMatch = rhs.match(/\((day|week|month|quarter|year)\)$/i);
          if (bucketMatch) {
            dateBucket = bucketMatch[1].toLowerCase();
            rhs = rhs.replace(/\s*\((day|week|month|quarter|year)\)$/i, '');
          }
          let agg = 'sum';
          let metric = null;
          const aggMatch = lhs.match(/^(count|sum|avg|min|max|distinct_count)\s*\(([^)]*)\)$/i);
          if (aggMatch) {
            agg = aggMatch[1].toLowerCase();
            const met = (aggMatch[2] || '').trim();
            metric = met && met !== '*' ? met : null;
          } else if (/^count$/i.test(lhs)) {
            agg = 'count';
            metric = null;
          }
          jobKey = { groupBy: rhs, metric, agg, dateBucket };
        }
      }

      if (!jobKey || !jobKey.groupBy || !jobKey.agg) {
        console.warn("Missing/invalid jobKey for saved card:", cardSnap?.title);
        return;
      }

      // Recompute aggregate from saved job definition
      const agg = groupAgg(ROWS, jobKey.groupBy, jobKey.metric ?? null, jobKey.agg, jobKey.dateBucket || '');

      const card = document.createElement('div'); card.className = 'card';
      // Persist job definition on the card for reliable future snapshots
      card.dataset.groupBy = jobKey.groupBy || '';
      card.dataset.metric = jobKey.metric || '';
      card.dataset.agg = jobKey.agg || '';
      card.dataset.dateBucket = jobKey.dateBucket || '';

      const head = document.createElement('div'); head.className = 'card-head';
      const left = document.createElement('div');
      const h = document.createElement('h4'); h.className = 'card-title'; h.textContent = cardSnap.title || `${agg.header[1]} by ${agg.header[0]}`;
      const sub = document.createElement('div'); sub.className = 'card-sub'; sub.textContent = `${agg.rows.length} groups · ${agg.header[1]}`;
      left.append(h, sub); head.append(left); card.appendChild(head);

      const chartsContainer = document.createElement('div'); chartsContainer.className = 'chart-cards'; card.appendChild(chartsContainer);

      (cardSnap.charts || []).forEach(chartSnap => {
        const type = chartSnap?.type || 'auto';
        const topN = Number(chartSnap?.topN) || 20;
        renderChartCard(agg, chartsContainer, type, topN, (cardSnap.title || `${agg.header[1]} by ${agg.header[0]}`).replace(/\s+/g, '_'));
      });

      const tableBox = document.createElement('div'); tableBox.className = 'table-wrap'; card.appendChild(tableBox); renderAggTable(agg, tableBox, 20);
      grid.appendChild(card);
    });

  } else {
    // Original logic for generating new aggregates from a plan
    const aggregates = plan.jobs.map(j => groupAgg(ROWS, j.groupBy, j.metric, j.agg, j.dateBucket||''));
    aggregates.forEach((agg, idx)=>{
      const intent = plan.charts.find(c=>c.useJob===idx) || {};
      const cfg = plan.jobs[idx] || {};
      const title = intent.title || `${agg.header[1]} by ${agg.header[0]}`;
      const card=document.createElement('div'); card.className='card';

      // Persist job definition on the card for reliable future snapshots
      card.dataset.groupBy = cfg.groupBy || '';
      card.dataset.metric = cfg.metric || '';
      card.dataset.agg = cfg.agg || '';
      card.dataset.dateBucket = cfg.dateBucket || '';

      const head=document.createElement('div'); head.className='card-head';
      const left=document.createElement('div');
      const h=document.createElement('h4'); h.className='card-title'; h.textContent=title;
      const sub=document.createElement('div'); sub.className='card-sub'; sub.textContent=`${agg.rows.length} groups · ${agg.header[1]}`;
      left.append(h, sub); head.append(left); card.appendChild(head);
      const controls=document.createElement('div'); controls.className='card-controls';
      card.appendChild(controls);
      const chartsContainer=document.createElement('div'); chartsContainer.className='chart-cards'; card.appendChild(chartsContainer);
      renderChartCard(agg, chartsContainer, intent.preferredType || cfg.chart || 'auto', Number(cfg.topN)||20, title.replace(/\s+/g,'_'));
      const tableBox=document.createElement('div'); tableBox.className='table-wrap'; card.appendChild(tableBox); renderAggTable(agg, tableBox, 20);
      grid.appendChild(card);
    });
  }

  // Initial layout after cards are added
  setTimeout(applyMasonryLayout, 150);
  setTimeout(applyMasonryLayout, 500);
  showToast('Cards generated successfully.', 'success');
}

/**
 * Masonry layout for variable-height .card elements inside #results.grid.
 * Uses ResizeObserver to recalc spans whenever a card resizes (e.g., Chart.js renders).
 */
let __masonryRO = null;

function applyMasonryLayout() {
  // Defer to ensure DOM and async content (charts) have a chance to render
  requestAnimationFrame(() => {
    requestAnimationFrame(() => {
      const grid = document.querySelector('#results.grid');
      if (!grid) return;

      // Disconnect previous observer to avoid duplicate callbacks
      if (__masonryRO) {
        try { __masonryRO.disconnect(); } catch {}
        __masonryRO = null;
      }

      const computed = window.getComputedStyle(grid);
      const autoRows = parseFloat(computed.getPropertyValue('grid-auto-rows')) || 10;
      const rowGap = parseFloat(computed.getPropertyValue('row-gap') || computed.getPropertyValue('grid-row-gap') || '0') || 0;

      // Helper to set a card's span based on its current rendered height
      const setSpan = (card) => {
        if (!card || !card.isConnected) return;
        // Clear previous span for accurate measurement
        card.style.gridRowEnd = '';
        const rect = card.getBoundingClientRect();
        const height = Math.max(0, Math.ceil(rect.height));
        // Avoid zero division; include gap in the denominator for accuracy
        const denom = Math.max(1, autoRows + rowGap);
        let span = Math.ceil((height + rowGap) / denom);
        // Ensure minimum span so collapsed cards don't disappear
        if (!Number.isFinite(span) || span < 2) span = 2;
        card.style.gridRowEnd = `span ${span}`;
      };

      const cards = Array.from(document.querySelectorAll('#results .card'));
      if (!cards.length) return;

      // Initial pass
      cards.forEach(setSpan);

      // Observe future size changes (e.g., charts finishing render, fonts loading, window resizes)
      __masonryRO = new ResizeObserver((entries) => {
        for (const entry of entries) {
          const el = entry.target;
          // Only handle cards inside our grid
          if (el && el.classList && el.classList.contains('card')) {
            setSpan(el);
          }
        }
      });

      cards.forEach(card => __masonryRO.observe(card));
    });
  });
}

/* ========= Modal accessibility: ESC & backdrop ========= */
window.addEventListener('resize', debounce(applyMasonryLayout, 200));
document.addEventListener('keydown', e=>{ if(e.key==='Escape'){ document.querySelectorAll('.modal.open').forEach(m=>m.classList.remove('open')); }});
['roleModal','aggModal', 'historyModal'].forEach(id=>{ const m = document.getElementById(id); m?.addEventListener('click', (e)=>{ if (e.target===m) m.classList.remove('open'); }); });

/* ========= Manual Save Handlers ========= */
$('#updateReportBtn').onclick = () => {
  if (!ROWS) return showToast('No data loaded to update.', 'error');
  if (!window.currentHistoryId) return showToast('No active report selected to update.', 'error');
  
  const currentName = $('#history-list .history-item[data-id="' + window.currentHistoryId + '"] .name')?.textContent || 'current report';
  if (confirm(`Are you sure you want to overwrite "${currentName}" with the current view?`)) {
    saveCurrentStateToHistory(currentName, false); // false = update existing
  }
};

$('#saveAsNewBtn').onclick = () => {
  if (!ROWS) return showToast('No data loaded to save.', 'error');
  
  const baseName = (LAST_PARSE_META && LAST_PARSE_META.fileName)
    ? LAST_PARSE_META.fileName.replace(/\.csv$/i, '')
    : 'Report';
  const defaultName = `${baseName} (copy) ${getFormattedDateTime()}`;
    
  const reportName = prompt('Enter a name for the new report:', defaultName);
  
  if (reportName) {
    saveCurrentStateToHistory(reportName, true); // true = force new entry
  }
};
/* ========= History Sidebar ========= */
const sidebar = $('#sidebar');
const toggleBtn = $('#sidebar-toggle');
// Accessibility: link button with sidebar and manage expanded state
toggleBtn.setAttribute('aria-controls', 'sidebar');

const SIDEBAR_COLLAPSE_KEY = 'csv-chart-v5:sidebar-collapsed';
function updateSidebarToggleA11y(){
  const expanded = !sidebar.classList.contains('collapsed');
  toggleBtn.setAttribute('aria-expanded', String(expanded));
  toggleBtn.setAttribute('aria-label', expanded ? 'Collapse sidebar' : 'Expand sidebar');
  const announcer = document.getElementById('sr-announcer');
  if (announcer) {
    announcer.textContent = expanded ? 'Sidebar expanded' : 'Sidebar collapsed';
  }
}
function applyStoredSidebarState(){
  try {
    const collapsed = localStorage.getItem(SIDEBAR_COLLAPSE_KEY) === '1';
    sidebar.classList.toggle('collapsed', collapsed);
  } catch {}
  updateSidebarToggleA11y();
}
toggleBtn.addEventListener('click', () => {
  const hadFocusInside = sidebar.contains(document.activeElement);
  const prevFocus = document.activeElement;

  sidebar.classList.toggle('collapsed');

  try {
    localStorage.setItem(SIDEBAR_COLLAPSE_KEY, sidebar.classList.contains('collapsed') ? '1' : '0');
  } catch {}

  updateSidebarToggleA11y();

  if (hadFocusInside) {
    requestAnimationFrame(() => {
      try {
        if (prevFocus && typeof prevFocus.focus === 'function' && document.contains(prevFocus)) {
          prevFocus.focus();
          return;
        }
      } catch {}
      const list = document.getElementById('history-list');
      const fallback = list?.querySelector('.history-item.active') || list?.querySelector('.history-item') || toggleBtn;
      fallback?.focus();
    });
  }
});
// Initialize from storage on load
applyStoredSidebarState();

async function renderHistorySidebar() {
  const list = $('#history-list');
  const searchInput = $('#history-search');
  const searchTerm = (searchInput.value || '').toLowerCase();
  list.innerHTML = '<li>Loading...</li>';
  try {
    let historyItems = await Store.listHistory();
    
    if (searchTerm) {
      historyItems = historyItems.filter(item =>
        (item.name || '').toLowerCase().includes(searchTerm)
      );
    }

    list.innerHTML = '';
    if (!historyItems.length) {
      list.innerHTML = `<li class="muted small" style="padding: 0 var(--s-4);">${searchTerm ? 'No matching reports found.' : 'No history yet.'}</li>`;
      return;
    }
    for (const item of historyItems) {
      const li = document.createElement('li');
      li.className = 'history-item';
      li.setAttribute('data-id', item.id);
      li.setAttribute('data-tooltip', item.name || 'Untitled');
      // a11y + keyboard: make entire item focusable and operable
      li.setAttribute('tabindex', '0');
      li.setAttribute('role', 'option');
      li.setAttribute('aria-label', item.name || 'Untitled');
      li.title = item.name || 'Untitled';
      if (item.id === window.currentHistoryId) {
        li.classList.add('active');
        li.setAttribute('aria-current', 'true');
        li.setAttribute('aria-selected', 'true');
      } else {
        li.removeAttribute('aria-selected');
      }

      const nameSpan = document.createElement('div');
      nameSpan.className = 'name';
      nameSpan.textContent = item.name || 'Untitled';
      nameSpan.title = item.name || 'Untitled';

      const metaDiv = document.createElement('div');
      metaDiv.className = 'meta';
      
      const dateSpan = document.createElement('span');
      dateSpan.innerHTML = `📅 ${new Date(item.updatedAt).toLocaleDateString()}`;
      
      const rowsSpan = document.createElement('span');
      rowsSpan.innerHTML = `≡ ${item.rowCount.toLocaleString()} rows`;

      const colsSpan = document.createElement('span');
      colsSpan.innerHTML = `📊 ${item.columns.length} cols`;

      metaDiv.append(dateSpan, rowsSpan, colsSpan);

      const actionsDiv = document.createElement('div');
      actionsDiv.className = 'actions';

      const loadBtn = document.createElement('button');
      loadBtn.className = 'load-btn';
      loadBtn.textContent = 'Load';
      loadBtn.onclick = (e) => {
        e.stopPropagation(); // prevent li click
        loadHistoryState(item.id);
      };
      
      if (item.status && item.status !== 'ready') {
        loadBtn.textContent = `Saving...`;
        loadBtn.disabled = true;
      }

      actionsDiv.appendChild(loadBtn);
      
      // Click anywhere on the item to load (buttons stop propagation)
      li.addEventListener('click', () => { loadHistoryState(item.id); });
      // Keyboard support: Enter/Space to load; ArrowUp/Down/Home/End to navigate
      li.addEventListener('keydown', (e) => {
        const key = e.key;
        if (key === 'Enter' || key === ' ') {
          e.preventDefault();
          loadHistoryState(item.id);
          return;
        }
        const items = Array.from(list.querySelectorAll('.history-item'));
        const i = items.indexOf(li);
        if (key === 'ArrowDown') {
          e.preventDefault();
          const next = items[Math.min(items.length - 1, i + 1)];
          next?.focus();
        } else if (key === 'ArrowUp') {
          e.preventDefault();
          const prev = items[Math.max(0, i - 1)];
          prev?.focus();
        } else if (key === 'Home') {
          e.preventDefault();
          items[0]?.focus();
        } else if (key === 'End') {
          e.preventDefault();
          items[items.length - 1]?.focus();
        }
      });
      
      li.append(nameSpan, metaDiv, actionsDiv);
      list.appendChild(li);
    }
  } catch (e) {
    console.error('Failed to render history', e);
    list.innerHTML = '<li class="muted small error">Could not load history.</li>';
  }
}

function getUiSnapshot() {
  return {
    mode: MODE,
    manualRoles: MANUAL_ROLES,
    manualJobs: MANUAL_JOBS,
    sort: SORT,
    query: QUERY,
    page: PAGE,
    rpp: RPP,
    charts: getChartsSnapshot(), // Capture the state of all rendered charts
  };
}

async function saveCurrentStateToHistory(fileName, forceNew = false) {
  if (!ROWS || !PROFILE) return;

  const toastId = `toast-${Date.now()}`;
  showToast('Saving report... 0%', 'info', 999999, toastId);

  try {
    const isUpdating = !forceNew && window.currentHistoryId;
    
    let finalName = fileName || 'Untitled Report';
    if (!isUpdating) {
      finalName = `${finalName.replace(/\s\d{4}-\d{2}-\d{2}\s\d{2}:\d{2}$/, '')} ${getFormattedDateTime()}`;
    }

    const historyItem = {
      id: isUpdating ? window.currentHistoryId : crypto.randomUUID(),
      sig: signatureFromHeaders(),
      name: finalName,
      columns: DATA_COLUMNS,
      rowCount: ROWS.length,
      meta: LAST_PARSE_META,
      uiSnapshot: getUiSnapshot(),
      status: 'saving',
    };

    const id = await Store.saveHistory(historyItem);
    window.currentHistoryId = id;
    await renderHistorySidebar();

    try {
      const chunkSize = 5000;
      const totalChunks = Math.ceil(ROWS.length / chunkSize);
      let idx = 0;
      for (let i = 0; i < ROWS.length; i += chunkSize) {
        const chunk = ROWS.slice(i, i + chunkSize);
        await Store.appendChunk(id, idx++, chunk);
        const progress = Math.round((idx / totalChunks) * 100);
        showToast(`Saving report... ${progress}%`, 'info', 999999, toastId);
        if (idx % 5 === 0) await new Promise(r => setTimeout(r, 0));
      }
      
      await Store.updateHistory(id, { status: 'ready' });
      showToast('Report saved successfully!', 'success', 3000, toastId);
    } catch (e) {
      console.error('Chunk saving failed:', e);
      await Store.updateHistory(id, { status: 'error' });
      showToast('Failed to save report data.', 'error', 3000, toastId);
    } finally {
      await renderHistorySidebar();
    }
  } catch (e) {
    console.error('Failed to save history', e);
    showToast('Failed to save history.', 'error', 3000, toastId);
  }
}

function getChartsSnapshot() {
  const charts = [];
  document.querySelectorAll('#results .card').forEach((card, cardIndex) => {
    const cardTitle = card.querySelector('.card-title')?.textContent || '';
    const cardCharts = [];

    const planJob = (window.CURRENT_PLAN && window.CURRENT_PLAN.jobs && window.CURRENT_PLAN.jobs[cardIndex]) || null;

    // Prefer the job definition persisted on the card (captures edits), fall back to plan
    const ds = card.dataset || {};
    const derivedJobKey = {
      groupBy: ds.groupBy || planJob?.groupBy || '',
      metric: (ds.metric !== undefined ? ds.metric : (planJob?.metric ?? '')) || '',
      agg: ds.agg || planJob?.agg || 'sum',
      dateBucket: ds.dateBucket || planJob?.dateBucket || ''
    };
    // Normalize metric: empty string means count
    if (derivedJobKey.metric === '') derivedJobKey.metric = null;

    card.querySelectorAll('.chart-card').forEach(chartCard => {
      const type = chartCard.querySelector('select')?.value || 'auto';
      const topN = chartCard.querySelector('input[type="number"]')?.value || '20';
      cardCharts.push({
        type,
        topN,
        jobKey: derivedJobKey
      });
    });
    charts.push({ title: cardTitle, cardJobKey: derivedJobKey, charts: cardCharts });
  });
  return charts;
}

async function loadHistoryState(id) {
  const toastId = `toast-${Date.now()}`;
  showToast('Loading report... 0%', 'info', 999999, toastId);
  try {
    const onProgress = (loaded, total) => {
      const progress = total > 0 ? Math.round((loaded / total) * 100) : 100;
      showToast(`Loading report... ${progress}%`, 'info', 999999, toastId);
    };

    const result = await Store.restoreHistory(id, onProgress);
    if (!result) {
      showToast('History item not found.', 'error', 3000, toastId);
      return;
    }
    
    const { history, rows } = result;

    if (history.status === 'saving') {
      showToast('This report is still saving. Please wait.', 'info', 3000, toastId);
      return;
    }
    if (history.status === 'error') {
      showToast('This report is corrupted and cannot be loaded.', 'error', 3000, toastId);
      return;
    }
    if (!rows) {
      showToast('Failed to load report data.', 'error', 3000, toastId);
      return;
    }

    // Restore data
    ROWS = rows;
    DATA_COLUMNS = history.columns || [];
    LAST_PARSE_META = history.meta || {};
    PROFILE = profile(ROWS);
    
    // Restore UI state from snapshot
    const snapshot = history.uiSnapshot || {};
    MODE = snapshot.mode || 'auto';
    MANUAL_ROLES = snapshot.manualRoles || {};
    MANUAL_JOBS = snapshot.manualJobs || [];
    SORT = snapshot.sort || { col: null, dir: 'asc' };
    QUERY = snapshot.query || '';
    PAGE = snapshot.page || 1;
    RPP = snapshot.rpp || 25;

    // Update UI elements
    $('#meta').textContent = `Loaded ${PROFILE.rowCount.toLocaleString()} rows from history.`;
    $('#searchInput').value = QUERY;
    $('#rowsPerPage').value = RPP;
    $('#mode').value = MODE;
    switchMode(MODE);
    
    // Render everything
    renderProfile(PROFILE);
    buildRawHeader(DATA_COLUMNS);
    applyFilter();
    renderRawBody();
    renderAggregates(snapshot.charts);

    window.currentHistoryId = id;
    showToast(`Loaded "${history.name || 'Untitled'}"`, 'success', 3000, toastId);
    renderHistorySidebar(); // To update active state
  } catch (e) {
    console.error('Failed to load history state', e);
    showToast('Error loading history state.', 'error', 3000, toastId);
  }
}

// Initial render
async function openHistoryManager() {
  const modal = $('#historyModal');
  const listContainer = $('#history-management-list');
  const selectAllCheckbox = $('#history-select-all');
  const deleteSelectedBtn = $('#deleteSelectedBtn');
  
  listContainer.innerHTML = 'Loading...';
  modal.classList.add('open');

  try {
    const historyItems = await Store.listHistory();
    listContainer.innerHTML = '';
    if (!historyItems.length) {
      listContainer.innerHTML = '<div class="muted small" style="padding: 8px;">No history to manage.</div>';
      selectAllCheckbox.disabled = true;
      return;
    }
    selectAllCheckbox.disabled = false;
    selectAllCheckbox.checked = false;

    historyItems.forEach(item => {
      const div = document.createElement('div');
      div.className = 'history-manage-item';
      div.style.display = 'flex';
      div.style.alignItems = 'center';
      div.style.gap = '8px';
      div.style.padding = '8px';
      div.style.border = '1px solid var(--border)';
      div.style.borderRadius = 'var(--radius-xs)';

      const checkbox = document.createElement('input');
      checkbox.type = 'checkbox';
      checkbox.setAttribute('data-id', item.id);
      checkbox.className = 'history-item-checkbox';

      const nameSpan = document.createElement('span');
      nameSpan.textContent = item.name;
      nameSpan.style.flexGrow = '1';

      const renameBtn = document.createElement('button');
      renameBtn.textContent = 'Rename';
      renameBtn.onclick = async () => {
        const newName = prompt('Enter new name for this report:', item.name);
        if (newName && newName.trim() !== '') {
          await Store.updateHistory(item.id, { name: newName.trim() });
          showToast('Report renamed.', 'success');
          await renderHistorySidebar();
          openHistoryManager(); // Refresh the modal list
        }
      };

      const deleteBtn = document.createElement('button');
      deleteBtn.textContent = 'Delete';
      deleteBtn.style.background = '#fee2e2';
      deleteBtn.style.color = '#b91c1c';
      deleteBtn.style.border = '1px solid #fecaca';
      deleteBtn.onclick = async () => {
        if (confirm(`Are you sure you want to delete "${item.name}"?`)) {
          await Store.deleteHistory(item.id);
          showToast('Report deleted.', 'success');
          await renderHistorySidebar();
          openHistoryManager(); // Refresh the modal list
        }
      };

      div.append(checkbox, nameSpan, renameBtn, deleteBtn);
      listContainer.appendChild(div);
    });

    // Add event listeners for bulk actions
    const checkboxes = listContainer.querySelectorAll('.history-item-checkbox');
    
    function updateDeleteButtonState() {
      const selected = listContainer.querySelectorAll('.history-item-checkbox:checked');
      deleteSelectedBtn.disabled = selected.length === 0;
      if (!deleteSelectedBtn.disabled) {
        deleteSelectedBtn.style.background = '#f87171';
        deleteSelectedBtn.style.color = '#7f1d1d';
        deleteSelectedBtn.style.cursor = 'pointer';
      } else {
        deleteSelectedBtn.style.background = '#fca5a5';
        deleteSelectedBtn.style.color = '#7f1d1d';
        deleteSelectedBtn.style.cursor = 'not-allowed';
      }
    }

    checkboxes.forEach(cb => cb.addEventListener('change', updateDeleteButtonState));
    
    selectAllCheckbox.onchange = () => {
      checkboxes.forEach(cb => cb.checked = selectAllCheckbox.checked);
      updateDeleteButtonState();
    };
    
    updateDeleteButtonState();

  } catch (e) {
    console.error('Failed to load history for management', e);
    listContainer.innerHTML = '<div class="muted small error" style="padding: 8px;">Could not load history.</div>';
  }
}

$('#manageHistoryBtn').onclick = openHistoryManager;
$('#closeHistoryModal').onclick = () => $('#historyModal').classList.remove('open');

$('#deleteSelectedBtn').onclick = async () => {
  const selected = document.querySelectorAll('#history-management-list .history-item-checkbox:checked');
  if (selected.length === 0) return;

  if (confirm(`Are you sure you want to delete ${selected.length} selected report(s)?`)) {
    for (const cb of selected) {
      const id = cb.getAttribute('data-id');
      await Store.deleteHistory(id);
    }
    showToast(`${selected.length} report(s) deleted.`, 'success');
    await renderHistorySidebar();
    openHistoryManager(); // Refresh modal
  }
};

$('#clearAllHistoryBtn').onclick = async () => {
  if (confirm('Are you sure you want to delete ALL saved reports? This action cannot be undone.')) {
    const historyItems = await Store.listHistory();
    for (const item of historyItems) {
      await Store.deleteHistory(item.id);
    }
    showToast('All history has been cleared.', 'success');
    await renderHistorySidebar();
    $('#historyModal').classList.remove('open');
  }
};

document.addEventListener('DOMContentLoaded', renderHistorySidebar);
$('#history-search').addEventListener('input', debounce(renderHistorySidebar, 250));

</script>
</main>
</body>
</html>
